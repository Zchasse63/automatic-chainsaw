{
  "created_at": 1771261208,
  "id": "resp_dccf2fdd-143b-478e-b675-ab43f7e17f5b",
  "model": "anthropic/claude-opus-4-6",
  "object": "response",
  "output": [
    {
      "queries": [
        "Next.js 16 App Router route handlers middleware 2025 2026",
        "Supabase Auth SSR Next.js App Router @supabase/ssr 2025 2026",
        "TanStack Query v5 Next.js App Router server components 2026"
      ],
      "results": [
        {
          "date": "2025-12-05",
          "id": 1,
          "last_updated": "2026-02-16T11:32:23",
          "snippet": "## Why Use Next.js Route Handlers?\n\nRoute handlers are ideal whenever your application needs server-side logic that sits outside the React rendering lifecycle. In practice, they\u2019re a great fit for:\n\n**Shared API logic with Higher-Order Functions (HOFs)**: Apply logging, validation, authorization, or context forwarding across multiple REST endpoints without repeating code. **Backend responsibilities without a backend server**: Route handlers can perform tasks such as:\n\n\u2026\n\n- CSV export route: Generate downloadable invoice data directly from a route handler.\n\n- Locale-aware currency conversion route: Transform data using live exchange rates, plus a proxy that redirects based on the client\u2019s IP.\n\n- Redirect management system: A middleware powered by Vercel Edge Config and a dedicated route handler for efficient redirect lookups.\n\nBy the end, you'll see how route handlers can cleanly encapsulate backend logic without needing a separate API service.\n\n\u2026\n\nRoute handlers use\n\n`NextRequest` and\n\n`NextResponse`, which extend the native Web APIs (Request and Response) with features optimized for the Next.js runtime:\n\n- Access to cookies and headers\n\n- URL utilities\n\n- Built-in JSON helpers\n\n- Enhanced redirect and response handling\n\nThese abstractions make building REST endpoints in the App Router ergonomic and familiar.\n\n\u2026\n\n- Sitewide auth \u2014 via OAuth, NextAuth.js, credentials, SSO, or JWT sessions\n\n- Middleware-based authorization \u2014 using middleware.ts with matcher patterns for RBAC or LBAC\n\n- Higher-order function (HOF) middleware \u2014 apply shared logic (auth, validation, logging) to groups of route handlers\n\n- Service-specific SDKs \u2014 attach access tokens to requests for external services (e.g., Stripe, Strapi, Vercel APIs)\n\n- Custom per-handler logic \u2014 manually adding headers inside individual route handlers, adding auth tokens to request headers from individual route handlers.\n\n\u2026\n\n### Use Case 3: Redirect Management with Middleware + Vercel Edge Config\n\nFor the final example, we\u2019ll build a redirect management system that:\n\n- Stores redirect rules in Vercel Edge Config\n\n- Uses a dedicated route handler to fetch individual redirect entries\n\n- Uses a middleware (in Next.js 16, proxy.ts) to decide whether to redirect a request\n\n\u2026\n\nWhat this does:\n\n- Reads the path parameter from the URL\n\n- Uses get() from @vercel/edge-config to read the corresponding redirect entry\n\n- Returns the entry as JSON\n\n**Step 3: Middleware to Apply Redirects**\n\nFinally, we wire up a middleware that:\n\n- Normalizes the incoming\n\n`pathname`into a redirect key\n\n\u2026\n\n- Features A/B testing, where feature-related live user data is fetched through a route handler.\n\n- Handling webhooks from third-party services like payment gateways, instrumentation tools, CMS content providers, and the like.\n\n- Redirecting requests to a callback URL sent by third-party service workflows.\n\n- Implementing mailers from fetched/aggregated data.\n\n- Streaming responses from LLM models.\n\n- Handling server-sent events via the SSE protocol.\n\n\u2026\n\n**Apply scoped access control**. Use middleware matchers, location-based or role-based strategies, or shared higher-order middleware to keep endpoints secure and performant. **Leverage shared middleware**for context forwarding. Keep route handlers focused and push repeated logic, like auth, logging, or header injection, into shared HOF middleware where possible.\n\n## Summary\n\nIn this post, we explored how Next.js 16 route handlers can power both standard and advanced server-side features within an App Router application. We began by reviewing how route handlers implement RESTful JSON APIs and then added a CSV file download endpoint built entirely in a route handler.\n\nFrom there, we demonstrated how route handlers can take on more complex backend tasks, including a currency-conversion API backed by a location-aware proxy layer. We also implemented a redirect-management middleware using Vercel Edge Config and saw how a dedicated route handler improves performance by handling redirect lookups outside the middleware.",
          "source": "web",
          "title": "Next.js 16 Route Handlers Explained: 3 Advanced Use Cases - Strapi",
          "url": "https://strapi.io/blog/nextjs-16-route-handlers-explained-3-advanced-usecases"
        },
        {
          "date": "2026-02-14",
          "id": 2,
          "last_updated": "2026-02-15T20:23:03",
          "snippet": "",
          "source": "web",
          "title": "Use Supabase Auth with Next.js",
          "url": "https://supabase.com/docs/guides/auth/quickstarts/nextjs"
        },
        {
          "date": "2023-07-16",
          "id": 3,
          "last_updated": "2025-07-24T18:16:49.222952",
          "snippet": "Currently reading the example code and i noticed:\n\n```\nfunction getQueryClient() {\n  if (isServer) {\n    // Server: always make a new query client\n    return makeQueryClient()\n\n```\n\nso in theory i should be able to use makeQueryClient() on the RootLayout and use prefetching hooks as normal which would look like:\n```\nexport default function RootLayout({ children }: PropsWithChildren) {\n  const { initDataRaw } = retrieveLaunchParams();\n  const queryClient = new QueryClient({\n    defaultOptions: {\n      queries: {\n        staleTime: 60 * 1000,\n      },\n    },\n  })\n\n  const data = queryClient.prefetchQuery({\n    queryKey: ['current_user'],\n    queryFn: () => validateUser({ value: initDataRaw! }),\n  })\n\n```",
          "source": "web",
          "title": "Does TanStack (React) Query work with the Next.js App router (React Server Components) \u00b7 TanStack query \u00b7 Discussion #5725",
          "url": "https://github.com/TanStack/query/discussions/5725"
        },
        {
          "date": "2026-02-11",
          "id": 4,
          "last_updated": "2026-02-16T13:08:40",
          "snippet": "",
          "source": "web",
          "title": "Getting Started: Route Handlers | Next.js",
          "url": "https://nextjs.org/docs/app/getting-started/route-handlers"
        },
        {
          "date": "2026-02-15",
          "id": 5,
          "last_updated": "2026-02-16T01:54:15",
          "snippet": "",
          "source": "web",
          "title": "Build a User Management App with Next.js | Supabase Docs",
          "url": "https://supabase.com/docs/guides/getting-started/tutorials/with-nextjs"
        },
        {
          "date": "2025-08-19",
          "id": 6,
          "last_updated": "2026-02-11T11:08:14",
          "snippet": "## Step 2: Setting Up the Provider for App Router\n\nUnlike the Pages Router, which has a centralized\n\n`_app.tsx` file, in the App Router, we need to create our own provider component that runs on the client-side (\n\n`'use client'`).\n\n\u2026\n\n### Create the Provider Component\n\nNext, create a component that will provide the\n\n`QueryClient` to your entire application.\n\nCreate a new file at\n\n`src/components/shared/Providers.tsx`:\n\n```\n\n// src/components/shared/Providers.tsx\n\n\"use client\";\n\nimport React from \"react\";\n\nimport { QueryClientProvider } from \"@tanstack/react-query\";\n\nimport queryClient from \"@/lib/query-client\";\n\nfunction Providers({ children }: React.PropsWithChildren) {\n\nreturn (\n\n<QueryClientProvider client={queryClient}>{children}</QueryClientProvider>\n\n);\n\n\n\nexport default Providers;\n\n```",
          "source": "web",
          "title": "The Complete Guide to TanStack Query in Next.js App Router",
          "url": "https://ihsaninh.com/blog/the-complete-guide-to-tanstack-query-next.js-app-router"
        },
        {
          "date": "2025-10-21",
          "id": 7,
          "last_updated": "2026-02-16T05:54:34",
          "snippet": "",
          "source": "web",
          "title": "Next.js 16",
          "url": "https://nextjs.org/blog/next-16"
        },
        {
          "date": "2023-11-22",
          "id": 8,
          "last_updated": "2024-12-19T15:37:54.678806",
          "snippet": "# Supabase Auth with the Next.js App Router\n\ncaution\n\nWe generally recommend using the new\n\n`@supabase/ssr` package instead of\n\n`auth-helpers`.\n\n`@supabase/ssr` takes the core concepts of the Auth Helpers package and makes them available to any server framework. Check out the migration doc to learn more.\n\n\u2026\n\nTo make this work with Next.js, we create a callback Route Handler that performs this exchange:\n\nCreate a new file at\n\n`app/auth/callback/route.js` and populate with the following:\n_17import { createRouteHandlerClient } from '@supabase/auth-helpers-nextjs'_17import { cookies } from 'next/headers'_17import { NextResponse } from 'next/server'_17_17export async function GET(request) {_17 const requestUrl = new URL(request.url)_17 const code\n\n\u2026\n\nuseState('')_51 const [password, setPassword] = useState('')_51 const router = useRouter()_51 const supabase = createClientComponentClient()_51_51 const handleSignUp = async () => {_51 await supabase.auth.signUp({_51 email,_51 password,\n_51 options: {_51 emailRedirectTo: `${location.origin}/auth/callback`,_51 },_51 })_51 router.refresh()_51 }_51_51 const handleSignIn = async () => {_51 await supabase.auth.signInWithPassword({_51 email,_51 password,_51 })_51\n\n\u2026\n\n#### Sign Up Route#\n_24import { createRouteHandlerClient } from '@supabase/auth-helpers-nextjs'_24import { cookies } from 'next/headers'_24import { NextResponse } from 'next/server'_24_24export async function POST(request) {_24 const requestUrl = new URL(request.url)_24 const formData\n= await request.formData()_24 const email = formData.get('email')_24 const password = formData.get('password')_24 const cookieStore = cookies()_24 const supabase = createRouteHandlerClient({ cookies: () => cookieStore })_24_24 await supabase.auth.signUp({_24 email,_24 password,_24 options: {_24 emailRedirectTo: `${requestUrl.origin}/auth/callback`,_24 },_24 })_24_24 return NextResponse.redirect(requestUrl.origin, {_24 status: 301,_24 })_24}\n\n\u2026\n\n{_20 'use server'_20_20 const title = formData.get('title')_20 const supabase = createServerActionClient({ cookies })_20 await supabase.from('todos').insert({ title })_20 revalidatePath('/')_20 }_20_20 return (_20 <form action={addTodo}>_20 <input name=\"title\" />_20 </form>_20 )_20}\n\n\u2026\n\n#### Route Handlers#\n\n_14import { createClient } from '@supabase/supabase-js'_14import { NextResponse } from 'next/server'_14_14export async function POST(request) {_14 const { title } = await request.json()_14_14 const supabase = createClient(_14 process.env.NEXT_PUBLIC_SUPABASE_URL,_14 process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY_14 )_14_14 const { data } = await supabase.from('todos').insert({ title }).select()_14 return NextResponse.json(data)_14}",
          "source": "web",
          "title": "Supabase Auth with the Next.js App Router",
          "url": "https://docs-9t0nr0rx3-supabase.vercel.app/docs/guides/auth/auth-helpers/nextjs"
        },
        {
          "date": "2017-02-01",
          "id": 9,
          "last_updated": "2025-11-29T11:02:45.496748",
          "snippet": "Converting this to the app router actually looks pretty similar, we just need to move things around a bit. First, we'll create a Server Component to do the prefetching part:",
          "source": "web",
          "title": "Advanced Server Rendering | TanStack Query React Docs",
          "url": "https://tanstack.com/query/latest/docs/framework/react/guides/advanced-ssr"
        },
        {
          "date": "2025-01-01",
          "id": 10,
          "last_updated": "2025-10-30T05:47:08.713230",
          "snippet": "",
          "source": "web",
          "title": "Route Handlers | Next.js 16 \u65e5\u672c\u8a9e\u30c9\u30ad\u30e5\u30e1\u30f3\u30c8",
          "url": "https://nextjsjp.org/docs/app/getting-started/route-handlers"
        },
        {
          "date": "2024-05-10",
          "id": 11,
          "last_updated": "2026-02-16T10:39:29",
          "snippet": "",
          "source": "web",
          "title": "The Right Way to do Auth with the Next.js App Router - UPDATED",
          "url": "https://www.youtube.com/watch?v=v6UvgfSIjQ0"
        },
        {
          "date": "2024-01-10",
          "id": 12,
          "last_updated": "2025-07-02T19:01:23.322693",
          "snippet": "",
          "source": "web",
          "title": "React Query with Next.js Server Components",
          "url": "https://www.youtube.com/watch?v=AnRshBKUApg"
        },
        {
          "date": "2024-03-05",
          "id": 13,
          "last_updated": "2025-01-28T19:12:08.295410",
          "snippet": "## Matching Paths\n\nMiddleware will be invoked for\n\n**every route in your project**. The following is the execution order:\n\n`headers`from\n\n`next.config.js`\n\n`redirects`from\n\n`next.config.js`\n\n- Middleware (\n\n`rewrites`,\n\n`redirects`, etc.)\n\n`beforeFiles`(\n\n\u2026\n\n```\n\nimport { NextRequest } from 'next/server'\n\nimport { isAuthenticated } from '@lib/auth'\n\n// Limit the middleware to paths starting with `/api/`\n\nexport const config = {\n\nmatcher: '/api/:function*',\n\n\n\nexport function middleware(request: NextRequest) {\n\n// Call our authentication function to check the request\n\nif (!isAuthenticated(request)) {\n\n// Respond with JSON indicating an error message\n\nreturn Response.json(\n\n{ success: false, message: 'authentication failed' },\n\n{ status: 401 }\n\n\n\n```",
          "source": "web",
          "title": "Routing: Middleware | Next.js",
          "url": "https://docsarchive.dev/nextjs/13.5/using-app-router/building-your-application/routing/middleware/"
        },
        {
          "date": "2019-10-12",
          "id": 14,
          "last_updated": "2025-05-27T11:08:57.865628",
          "snippet": "The\n```\nauth-helpers\n```\npackage has been replaced with the\n```\n@supabase/ssr\n```\npackage. We recommend setting up Auth for your Next.js app with\n```\n@supabase/ssr\n```\ninstead. See the Next.js Server-Side Auth guide to learn how.",
          "source": "web",
          "title": "supabase/apps/docs/content/guides/auth/auth-helpers/nextjs-pages.mdx at master \u00b7 supabase/supabase",
          "url": "https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/auth-helpers/nextjs-pages.mdx"
        },
        {
          "date": "2023-10-17",
          "id": 15,
          "last_updated": "2026-02-05T17:01:52.349696",
          "snippet": "",
          "source": "web",
          "title": "Announcing TanStack Query v5",
          "url": "https://tanstack.com/blog/announcing-tanstack-query-v5"
        }
      ],
      "type": "search_results"
    },
    {
      "contents": [
        {
          "snippet": "Use Supabase Auth with Next.js\n\nLearn how to configure Supabase Auth for the Next.js App Router.\n\n### Create a new Supabase project\n\nHead over to database.new and create a new Supabase project.\n\nYour new database has a table for storing your users. You can see that this table is currently empty by running some SQL in the SQL Editor.\n\n###### SQL_EDITOR\n\n`1select * from auth.users;`\n\n### Create a Next.js app\n\nUse the\n\n`create-next-app` command and the\n\n`with-supabase` template, to create a Next.js app pre-configured with:\n\n\n\n##### Explore drop-in UI components for your Supabase app.\n\nUI components built on shadcn/ui that connect to Supabase via a single command.Explore Components\n\n###### Terminal\n\n`1npx create-next-app -e with-supabase`\n\n### Declare Supabase Environment Variables\n\nRename\n\n`.env.example` to\n\n`.env.local` and populate with your Supabase connection variables:\n\n###### Project URL\n\n###### Publishable key\n\n###### Anon key\n\n###### .env.local\n\n`1NEXT_PUBLIC_SUPABASE_URL=your-project-url2NEXT_PUBLIC_SUPABASE_PUBLISHABLE_KEY=sb_publishable_... or anon key`\n\nYou can also get the Project URL and key from the project's\n\n**Connect** dialog.\n\n##### Changes to API keys\n\nSupabase is changing the way keys work to improve project security and developer experience. You can read the full announcement, but in the transition period, you can use both the current\n\n`anon` and\n\n`service_role` keys and the new publishable key with the form\n\n`sb_publishable_xxx` which will replace the older keys.\n\nIn most cases, you can get the correct key from the Project's\n\n**Connect** dialog, but if you want a specific key, you can find all keys in the API Keys section of a Project's Settings page: **For legacy keys**, copy the\n\n`anon`key for client-side operations and the\n\n`service_role`key for server-side operations from the\n\n**Legacy API Keys**tab. **For new keys**, open the **API Keys**tab, if you don't have a publishable key already, click **Create new API Keys**, and copy the value from the **Publishable key**section.\n\nRead the API keys docs for a full explanation of all key types and their uses.\n\n### Start the app\n\nStart the development server, go to http://localhost:3000 in a browser, and you should see the contents of\n\n`app/page.tsx`.\n\nTo sign up a new user, navigate to http://localhost:3000/auth/sign-up, and click\n\n`Sign up`.\n\n###### Terminal\n\n`1npm run dev`\n\n## Learn more\n\n- Setting up Server-Side Auth for Next.js for a Next.js deep dive\n\n- Supabase Auth docs for more Supabase authentication methods\n\n",
          "title": "Use Supabase Auth with Next.js",
          "url": "https://supabase.com/docs/guides/auth/quickstarts/nextjs"
        },
        {
          "snippet": "Tuesday, October 21st 2025\n\n# Next.js 16Posted byJimmy Lai@feedthejimJosh Story@joshcstorySebastian Markb\u00e5ge@sebmarkbageTim Neutkens@timneutkens\n\nAhead of our upcoming Next.js Conf 2025, Next.js 16 is now available.\n\nThis release provides the latest improvements to Turbopack, caching, and the Next.js architecture. Since the previous beta release, we added several new features and improvements:\n\n**Cache Components**: New model using Partial Pre-Rendering (PPR) and use cache for instant navigation. **Next.js Devtools MCP**: Model Context Protocol integration for improved debugging and workflow. **Proxy**: Middleware replaced by\n\n`proxy.ts`to clarify network boundary.\n\n**DX**: Improved logging for builds and development requests.\n\nFor reminder, those features were available since the previous beta release:\n\n**Turbopack (stable)**: Default bundler for all apps with up to 5-10x faster Fast Refresh, and 2-5x faster builds **Turbopack File System Caching (beta)**: Even faster startup and compile times for the largest apps **React Compiler Support (stable)**: Built-in integration for automatic memoization **Build Adapters API (alpha)**: Create custom adapters to modify the build process **Enhanced Routing**: Optimized navigations and prefetching with layout deduplication and incremental prefetching **Improved Caching APIs**: New\n\n`updateTag()`and refined\n\n`revalidateTag()`\n\n**React 19.2**: View Transitions,\n\n`useEffectEvent()`,\n\n`<Activity/>`\n\n**Breaking Changes**: Async params,\n\n`next/image`defaults, and more\n\nUpgrade to Next.js 16:terminal\n\n```\n\n# Use the automated upgrade CLI\n\nnpx @next/codemod@canary upgrade latest\n\n# ...or upgrade manually\n\nnpm install next@latest react@latest react-dom@latest\n\n# ...or start a new project\n\nnpx create-next-app@latest\n\n```\n\nFor cases where the codemod can't fully migrate your code, please read the upgrade guide.\n\n## New Features and Improvements\n\n### Cache Components\n\nCache Components are a new set of features designed to make caching in Next.js both more explicit, and more flexible. They center around the new\n\n`\"use cache\"` directive, which can be used to cache pages, components, and functions, and which leverages the compiler to automatically generate cache keys wherever it\u2019s used.\n\nUnlike the implicit caching found in previous versions of the App Router, caching with Cache Components is entirely opt-in. All dynamic code in any page, layout, or API route is executed at request time by default, giving Next.js an out-of-the-box experience that\u2019s better aligned with what developers expect from a full-stack application framework.\n\nCache Components also complete the story of Partial Prerendering (PPR), which was first introduced in 2023. Prior to PPR, Next.js had to choose whether to render each URL statically or dynamically; there was no middle ground. PPR eliminated this dichotomy, and let developers opt portions of their static pages into dynamic rendering (via Suspense) without sacrificing the fast initial load of fully static pages.\n\nYou can enable Cache Components in your\n\n`next.config.ts` file:\n\n```\n\nconst nextConfig = {\n\ncacheComponents: true,\n\n};\n\nexport default nextConfig;\n\n```\n\nWe will be sharing more about Cache Components and how to use them at Next.js Conf 2025 on October 22nd, and we will be sharing more content in our blog and documentation in the coming weeks.\n\nNote:as previously announced in the beta release, the previous experimental\n\n`experimental.ppr`flag and configuration options have been removed in favor of the Cache Components configuration.\n\nLearn more in the documentation here.\n\n### Next.js Devtools MCP\n\nNext.js 16 introduces\n\n**Next.js DevTools MCP**, a Model Context Protocol integration for AI-assisted debugging with contextual insight into your application.\n\nThe Next.js DevTools MCP provides AI agents with:\n\n**Next.js knowledge**: Routing, caching, and rendering behavior **Unified logs**: Browser and server logs without switching contexts **Automatic error access**: Detailed stack traces without manual copying **Page awareness**: Contextual understanding of the active route\n\nThis enables AI agents to diagnose issues, explain behavior, and suggest fixes directly within your development workflow.\n\nLearn more in the documentation here.\n\n`proxy.ts` (formerly\n\n`middleware.ts`)\n\n`proxy.ts` replaces\n\n`middleware.ts` and makes the app\u2019s network boundary explicit.\n\n`proxy.ts` runs on the Node.js runtime.\n\n**What to do**: Rename\n\n`middleware.ts`\u2192\n\n`proxy.ts`and rename the exported function to\n\n`proxy`. Logic stays the same.\n\n**Why**: Clearer naming and a single, predictable runtime for request interception.\n\n```\n\nexport default function proxy(request: NextRequest) {\n\nreturn NextResponse.redirect(new URL('/home', request.url));\n\n\n\n```\n\nNote:The\n\n`middleware.ts`file is still available for Edge runtime use cases, but it is deprecated and will be removed in a future version.\n\nLearn more in the documentation here.\n\n### Logging Improvements\n\nIn Next.js 16 the development request logs are extended showing where time is spent.\n\n- Compile: Routing and compilation\n\n- Render: Running your code and React rendering\n\nThe build is also extended to show where time is spent. Each step in the build process is now shown with the time it took to complete.terminal\n\n```\n\n\u25b2 Next.js 16 (Turbopack)\n\n\u2713 Compiled successfully in 615ms\n\n\u2713 Finished TypeScript in 1114ms\n\n\u2713 Collecting page data in 208ms\n\n\u2713 Generating static pages in 239ms\n\n\u2713 Finalizing page optimization in 5ms\n\n```\n\nThe following features were previously announced in the beta release:\n\n### Developer Experience\n\n#### Turbopack (stable)\n\nTurbopack has reached stability for both development and production builds, and is now the default bundler for all new Next.js projects. Since its beta release earlier this summer, adoption has scaled rapidly: more than 50% of development sessions and 20% of production builds on Next.js 15.3+ are already running on Turbopack.\n\nWith Turbopack, you can expect:\n\n- 2\u20135\u00d7 faster production builds\n\n- Up to 10\u00d7 faster Fast Refresh\n\nWe're making Turbopack the default to bring these performance gains to every Next.js developer, no configuration required. For apps with custom webpack setups, you can continue using webpack by running:terminal\n\n```\n\nnext dev --webpack\n\nnext build --webpack\n\n```\n\n#### Turbopack File System Caching (beta)\n\nTurbopack now supports filesystem caching in development, storing compiler artifacts on disk between runs for significantly faster compile times across restarts, especially in large projects.\n\nEnable filesystem caching in your configuration:next.config.ts\n\n```\n\nconst nextConfig = {\n\nexperimental: {\n\nturbopackFileSystemCacheForDev: true,\n\n},\n\n};\n\nexport default nextConfig;\n\n```\n\nAll internal Vercel apps are already using this feature, and we\u2019ve seen notable improvements in developer productivity across large repositories.\n\nWe\u2019d love to hear your feedback as we iterate on filesystem caching. Please try it out and share your experience.\n\n#### Simplified\n\n`create-next-app`\n\n`create-next-app` has been redesigned with a simplified setup flow, updated project structure, and improved defaults. The new template includes the App Router by default, TypeScript-first configuration, Tailwind CSS, and ESLint.\n\n#### Build Adapters API (alpha)\n\nFollowing the Build Adapters RFC, we've worked with the community and deployment platforms to deliver the first alpha version of the Build Adapters API.\n\nBuild Adapters allow you to create custom adapters that hook into the build process, enabling deployment platforms and custom build integrations to modify Next.js configuration or process build output.next.config.js\n\n```\n\nconst nextConfig = {\n\nexperimental: {\n\nadapterPath: require.resolve('./my-adapter.js'),\n\n},\n\n};\n\nmodule.exports = nextConfig;\n\n```\n\nShare your feedback in the RFC discussion.\n\n#### React Compiler Support (stable)\n\nBuilt-in support for the React Compiler is now stable in Next.js 16 following the React Compiler's 1.0 release. The React Compiler automatically memoizes components, reducing unnecessary re-renders with zero manual code changes.\n\nThe\n\n`reactCompiler` configuration option has been promoted from\n\n`experimental` to stable. It is not enabled by default as we continue gathering build performance data across different application types. Expect compile times in development and during builds to be higher when enabling this option as the React Compiler relies on Babel.\n\n```\n\nconst nextConfig = {\n\nreactCompiler: true,\n\n};\n\nexport default nextConfig;\n\n```\n\nInstall the latest version of the React Compiler plugin:terminal\n\n`npm install babel-plugin-react-compiler@latest`\n\n### Core Features & Architecture\n\n#### Enhanced Routing and Navigation\n\nNext.js 16 includes a complete overhaul of the routing and navigation system, making page transitions leaner and faster.\n\n**Layout deduplication**: When prefetching multiple URLs with a shared layout, the layout is downloaded once instead of separately for each Link. For example, a page with 50 product links now downloads the shared layout once instead of 50 times, dramatically reducing the network transfer size.\n\n**Incremental prefetching**: Next.js only prefetches parts not already in cache, rather than entire pages. The prefetch cache now:\n\n- Cancels requests when the link leaves the viewport\n\n- Prioritizes link prefetching on hover or when re-entering the viewport\n\n- Re-prefetches links when their data is invalidated\n\n- Works seamlessly with upcoming features like Cache Components\n\n**Trade-off**: You may see more individual prefetch requests, but with much lower total transfer sizes. We believe this is the right trade-off for nearly all applications. If the increased request count causes issues, please let us know. We're working on additional optimizations to inline data chunks more efficiently.\n\nThese changes require no code modifications and are designed to improve performance across all apps.\n\n#### Improved Caching APIs\n\nNext.js 16 introduces refined caching APIs for more explicit control over cache behavior.\n\n`revalidateTag()` (updated)\n\n`revalidateTag()` now requires a\n\n** as the second argument to enable stale-while-revalidate (SWR) behavior: cacheLife profile**\n\n```\n\nimport { revalidateTag } from 'next/cache';\n\n// \u2705 Use built-in cacheLife profile (we recommend 'max' for most cases)\n\nrevalidateTag('blog-posts', 'max');\n\n// Or use other built-in profiles\n\nrevalidateTag('news-feed', 'hours');\n\nrevalidateTag('analytics', 'days');\n\n// Or use an inline object with a custom revalidation time\n\nrevalidateTag('products', { expire: 3600 });\n\n// \u26a0\ufe0f Deprecated - single argument form\n\nrevalidateTag('blog-posts');\n\n```\n\nThe profile argument accepts built-in\n\n`cacheLife` profile names (like\n\n`'max'`,\n\n`'hours'`,\n\n`'days'`) or custom profiles defined in your\n\n`next.config`. You can also pass an inline\n\n`{ expire: number }` object. We recommend using\n\n`'max'` for most cases, as it enables background revalidation for long-lived content. When users request tagged content, they receive cached data immediately while Next.js revalidates in the background.\n\nUse\n\n`revalidateTag()` when you want to invalidate only properly tagged cached entries with stale-while-revalidate behavior. This is ideal for static content that can tolerate eventual consistency.\n\nMigration guidance:Add the second argument with a\n\n`cacheLife`profile (we recommend\n\n`'max'`) for SWR behavior, or use\n\n`updateTag()`in Server Actions if you need read-your-writes semantics.\n\n`updateTag()` (new)\n\n`updateTag()` is a new Server Actions-only API that provides\n\n**read-your-writes** semantics, expiring and immediately reading fresh data within the same request:\n\n```\n\n'use server';\n\nimport { updateTag } from 'next/cache';\n\nexport async function updateUserProfile(userId: string, profile: Profile) {\n\nawait db.users.update(userId, profile);\n\n// Expire cache and refresh immediately - user sees their changes right away\n\nupdateTag(`user-${userId}`);\n\n\n\n```\n\nThis ensures interactive features reflect changes immediately. Perfect for forms, user settings, and any workflow where users expect to see their updates instantly.\n\n`refresh()` (new)\n\n`refresh()` is a new Server Actions-only API for refreshing\n\n**uncached data only**. It doesn't touch the cache at all:\n\n```\n\n'use server';\n\nimport { refresh } from 'next/cache';\n\nexport async function markNotificationAsRead(notificationId: string) {\n\n// Update the notification in the database\n\nawait db.notifications.markAsRead(notificationId);\n\n// Refresh the notification count displayed in the header\n\n// (which is fetched separately and not cached)\n\nrefresh();\n\n\n\n```\n\nThis API is complementary to the client-side\n\n`router.refresh()`. Use it when you need to refresh uncached data displayed elsewhere on the page after performing an action. Your cached page shells and static content remain fast while dynamic data like notification counts, live metrics, or status indicators refresh.\n\n#### React 19.2 and Canary Features\n\nThe App Router in Next.js 16 uses the latest React Canary release, which includes the newly released React 19.2 features and other features being incrementally stabilized. Highlights include:\n\n**View Transitions**: Animate elements that update inside a Transition or navigation **: Extract non-reactive logic from Effects into reusable Effect Event functions**\n\n`useEffectEvent`\n\n**Activity**: Render \"background activity\" by hiding UI with\n\n`display: none`while maintaining state and cleaning up Effects\n\nLearn more in the React 19.2 announcement.\n\n### Breaking Changes and Other Updates\n\n#### Version Requirements\n\n|Change|Details|\n|--|--|\n|Node.js 20.9+|Minimum version now 20.9.0 (LTS); Node.js 18 no longer supported|\n|TypeScript 5+|Minimum version now 5.1.0|\n|Browsers|Chrome 111+, Edge 111+, Firefox 111+, Safari 16.4+|\n#### Removals\n\nThese features were previously deprecated and are now removed:\n\n|Removed|Replacement|\n|--|--|\n|AMP support|All AMP APIs and configs removed ( `useAmp`, `export const config = { amp: true }`)|\n|`next lint` command|Use Biome or ESLint directly; `next build` no longer runs linting. A codemod is available: `npx @next/codemod@canary next-lint-to-eslint-cli .`|\n|`devIndicators` options|`appIsrStatus`, `buildActivity`, `buildActivityPosition` removed from config. The indicator remains.|\n|`serverRuntimeConfig`, `publicRuntimeConfig`|Use environment variables ( `.env` files)|\n|`experimental.turbopack` location|Config moved to top-level `turbopack` (no longer in `experimental`)|\n|`experimental.dynamicIO` flag|Renamed to `cacheComponents`|\n|`experimental.ppr` flag|PPR flag removed; evolving into Cache Components programming model|\n|`export const experimental_ppr`|Route-level PPR export removed; evolving into Cache Components programming model|\n|Automatic `scroll-behavior: smooth`|Add `data-scroll-behavior=\"smooth\"` to HTML document to opt back in|\n|`unstable_rootParams()`|We are working on an alternative API that we will ship in an upcoming minor|\n|Sync access `params`, `searchParams` props|Must use async: `await params`, `await searchParams`|\n|Sync access `cookies()`, `headers()`, `draftMode()`|Must use async: `await cookies()`, `await headers()`, `await draftMode()`|\n|Metadata image route `params` argument|Changed to async `params`; `id` from `generateImageMetadata` now `Promise<string>`|\n|`next/image` local src with query strings|Now requires `images.localPatterns` config to prevent enumeration attacks|\n#### Behavior Changes\n\nThese features have new default behaviors in Next.js 16:\n\n|Changed Behavior|Details|\n|--|--|\n|Default bundler|Turbopack is now the default bundler for all apps; opt out with `next build --webpack`|\n|`images.minimumCacheTTL` default|Changed from 60s to 4 hours (14400s); reduces revalidation cost for images without cache-control headers|\n|`images.imageSizes` default|Removed `16` from default sizes (used by only 4.2% of projects); reduces srcset size and API variations|\n|`images.qualities` default|Changed from `[1..100]` to `[75]`; `quality` prop is now coerced to closest value in `images.qualities`|\n|`images.dangerouslyAllowLocalIP`|New security restriction blocks local IP optimization by default; set to `true` for private networks only|\n|`images.maximumRedirects` default|Changed from unlimited to 3 redirects maximum; set to `0` to disable or increase for rare edge cases|\n|`@next/eslint-plugin-next` default|Now defaults to ESLint Flat Config format, aligning with ESLint v10 which will drop legacy config support|\n|Prefetch cache behavior|Complete rewrite with layout deduplication and incremental prefetching|\n|`revalidateTag()` signature|Now requires `cacheLife` profile as second argument for stale-while-revalidate behavior|\n|Babel configuration in Turbopack|Automatically enables Babel if a babel config is found (previously exited with hard error)|\n|Terminal output|Redesigned with clearer formatting, better error messages, and improved performance metrics|\n|Dev and build output directories|`next dev` and `next build` now use separate output directories, enabling concurrent execution|\n|Lockfile behavior|Added lockfile mechanism to prevent multiple `next dev` or `next build` instances on the same project|\n|Parallel routes `default.js`|All parallel route slots now require explicit `default.js` files; builds fail without them. Create `default.js` that calls `notFound()` or returns `null` for previous behavior|\n|Modern Sass API|Bumped `sass-loader` to v16, which supports modern Sass syntax and new features|\n#### Deprecations\n\nThese features are deprecated in Next.js 16 and will be removed in a future version:\n\n|Deprecated|Details|\n|--|--|\n|`middleware.ts` filename|Rename to `proxy.ts` to clarify network boundary and routing focus|\n|`next/legacy/image` component|Use `next/image` instead for improved performance and features|\n|`images.domains` config|Use `images.remotePatterns` config instead for improved security restriction|\n|`revalidateTag()` single argument|Use `revalidateTag(tag, profile)` for SWR, or `updateTag(tag)` in Actions for read-your-writes|\n#### Additional Improvements\n\n**Performance improvements**: Significant performance optimizations for\n\n`next dev`and\n\n`next start`commands\n\n**Node.js native TypeScript for**: Run\n\n`next.config.ts`\n\n`next dev`,\n\n`next build`, and\n\n`next start`commands with\n\n`--experimental-next-config-strip-types`flag to enable native TypeScript for\n\n`next.config.ts`.\n\nWe'll aim to share a more comprehensive migration guide ahead of the stable release in our documentation.\n\n## Feedback and Community\n\nShare your feedback and help shape the future of Next.js:\n\n## Contributors\n\nNext.js is the result of the combined work of over 3,000 individual developers. This release was brought to you by:\n\n- The\n\n**Next.js**team: Andrew, Hendrik, Janka, Jiachi, Jimmy, Jiwon, JJ, Josh, Jude, Sam, Sebastian, Sebbie, Wyatt, and Zack.\n\n- The\n\n**Turbopack**team: Benjamin, Josh, Luke, Niklas, Tim, Tobias, and Will.\n\n- The\n\n**Next.js Docs**team: Delba, Rich, Ismael, and Joseph.\n\nHuge thanks to @mischnic, @timneutkens, @unstubbable, @wyattjoh, @Cy-Tek, @lukesandberg, @OoMNoO, @ztanner, @icyJoseph, @huozhi, @gnoff, @ijjk, @povilasv, @dwrth, @obendev, @aymericzip, @devjiwonchoi, @SyMind, @vercel-release-bot, @Shireee, @eps1lon, @dharun36, @kachkaev, @bgw, @yousefdawood7, @TheAlexLichter, @sokra, @ericx0099, @leerob, @Copilot, @fireairforce, @fufuShih, @anvibanga, @hayes, @Milancen123, @martinfrancois, @lubieowoce, @gaojude, @lachlanjc, @liketiger, @styfle, @aaronbrown-vercel, @Samii2383, @FelipeChicaiza, @kevva, @m1abdullahh, @F7b5, @Anshuman71, @RobertFent, @poteto, @chloe-yan, @sireesha-siri, @brian-lou, @joao4xz, @stefanprobst, @samselikoff, @acdlite, @gwkline, @bgub, @brock-statsig, and @karlhorky for helping!\n\n",
          "title": "Next.js 16",
          "url": "https://nextjs.org/blog/next-16"
        }
      ],
      "type": "fetch_url_results"
    },
    {
      "queries": [
        "Next.js 16 proxy.ts middleware replacement auth pattern 2025",
        "Supabase @supabase/ssr createServerClient createBrowserClient Next.js 2025",
        "Nebius Token Factory OpenAI compatible API streaming SSE"
      ],
      "results": [
        {
          "date": "2025-12-01",
          "id": 16,
          "last_updated": "2026-02-15T18:43:11",
          "snippet": "### The Change: middleware.ts is now proxy.ts\n\nNext.js 16 renames\n\n`middleware.ts` to\n\n`proxy.ts`. While the core functionality of intercepting requests remains similar, the new name better reflects its role as a lightweight routing layer rather than a place for heavy business logic.\n\nYou can now export a named proxy function from a",
          "source": "web",
          "title": "Server Actions And...",
          "url": "https://auth0.com/blog/whats-new-nextjs-16/"
        },
        {
          "date": "2024-04-10",
          "id": 17,
          "last_updated": "2025-09-01T19:47:53.023810",
          "snippet": "## lorikku Apr 10, 2024\n\n-\n\nSo I'm using\n```\n@supabase/ssr\n```\nto handle SSR with NextJS.\n\nI like to keep my API functions centralised into one api folder/file, so that I don't have to go looking for different queries in different components. The issue I ran into right now is that for every request, I have to create two separate versions that each use either\n```\ncreateServerClient\n```\nor\n```\ncreateBrowserClient\n```\n.\n\nI obviously don't want to keep doing this because it's too much overhead for no reason, so I thought let's conditionally check for\n```\nisServer ? createServerClient : createBrowserClient\n```\n. The problem is that my\n\n\u2026\n\n## Replies: 2 comments 3 replies\n\n- - - -\n### lorikku Apr 10, 2024 Author\n\n-\n\nI've also tried conditional importing, but that also doesn't work:\n\n```\nimport isServer from \"@/utils/isServer\";\n\nconst supabaseClient = isServer()\n  ? import(\"@/services/supabase/clients/server\").then(\n      (module) => module.default\n    )\n  : import(\"@/services/supabase/clients/browser\").then(\n      (module) => module.default\n    );\n\nexport default supabaseClient;\n```\n\n2 replies\n\n- -\n\n\u2026\n\n### Ziondido Jan 18, 2025\n\n-\n\nHey, I was thinking about this, and I came up with an idea that might work for your situation. Instead of splitting things into separate files, you can use a single function to handle both\n```\ncreateServerClient\n```\nand\n```\ncreateBrowserClient\n```\nby checking if you're running on the server or client. Here's how it could look:\n```\nimport { createBrowserClient, createServerClient } from '@supabase/ssr'\nimport { cookies } from 'next/headers'\n\nexport async function createClient() {\n  const isServer = typeof window === 'undefined' // Check if we're on the server\n\n  if (isServer) {\n    // Server-side logic\n    const cookieStore = cookies()\n\n    return createServerClient(\n      process.env.NEXT_PUBLIC_SUPABASE_URL!,\n      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\n      {\n        cookies: {\n          getAll() {\n            return cookieStore.getAll()\n          },\n          setAll(cookiesToSet) {\n            try {\n              cookiesToSet.forEach(({ name, value, options }) => {\n                cookieStore.set(name, value, options)\n              })\n            } catch {\n              // If it's running in a Server Component, just ignore\n            }\n          },\n        },\n      }\n    )\n  } else {\n    // Client-side logic\n    return createBrowserClient(\n      process.env.NEXT_PUBLIC_SUPABASE_URL!,\n      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!\n    )\n  }\n}\n```\nThe idea here is to check\n```\ntypeof window === 'undefined'\n```\nto decide whether to use the server or browser client. On the server, it initializes\n```\ncreateServerClient\n```\nwith\n```\nnext/headers\n```\ncookies, and on the client, it just uses\n```\ncreateBrowserClient\n```\n.\n\nIt seems like it should work, but I haven\u2019t tested it extensively, so let me know if it gives you any trouble or if you find a better way! Just thought it might simplify things by keeping everything in one place. \ud83d\ude0a\n\n1 reply\n\n- -",
          "source": "web",
          "title": "How to handle createServerClient & createBrowserClient in NextJS ...",
          "url": "https://github.com/orgs/supabase/discussions/22628"
        },
        {
          "date": "2025-11-05",
          "id": 18,
          "last_updated": "2025-12-10T14:20:16.175172",
          "snippet": "Run open-source AI at production speed\n\nDeploy models like Llama, Qwen, DeepSeek, GPT OSS on dedicated endpoints with sub-second targets and 99.9% uptime.\n\nAutoscaling, speculative decoding and multi-region routing keep latency predictable at any scale.\n\n## Scalability without constraints\n\nRun large open-source models on dedicated Nebius endpoints for consistent, sub-second performance. Seamlessly scale from prototype to full production and handle hundreds of millions of tokens per minute with autoscaling and 99.9% uptime.",
          "source": "web",
          "title": "Nebius Token Factory",
          "url": "https://nebius.com/services/token-factory"
        },
        {
          "date": "2025-10-24",
          "id": 19,
          "last_updated": "2026-02-16T08:33:54",
          "snippet": "### Transcript\n\n{ts:0} Hey everyone, Nexus S16 is here and in this video I want to zoom in on one\n{ts:4} change they made which is that middleware.ts the file name is now deprecated and we\n{ts:11} have to rename it to proxy.ts. So we're not going to have middleware anymore. we're going to have a proxy and\n\n\u2026\n\nIt's just a different way of structuring the\n{ts:887} code so that we as developers are less likely to make a mistake here because what we can do now we can couple the\n{ts:894} authentication check with the data access right so right now I still don't have any authentication here. So what",
          "source": "web",
          "title": "Next.js 16 Middleware DEPRECATED - Authentication In Proxy Or Data Access Layer?",
          "url": "https://www.youtube.com/watch?v=zNgCFXZLoRk"
        },
        {
          "date": "2026-02-13",
          "id": 20,
          "last_updated": "2026-02-13T19:15:23",
          "snippet": "View source\n\n`1import { createBrowserClient } from '@supabase/ssr'23export function createClient() {4 return createBrowserClient(5 process.env.NEXT_PUBLIC_SUPABASE_URL!,6 process.env.NEXT_PUBLIC_SUPABASE_PUBLISHABLE_KEY!7 )8}`",
          "source": "web",
          "title": "Creating a Supabase client for SSR",
          "url": "https://supabase.com/docs/guides/auth/server-side/creating-a-client"
        },
        {
          "date": "2025-11-05",
          "id": 21,
          "last_updated": "2026-01-31T21:38:26.384298",
          "snippet": "",
          "source": "web",
          "title": "Introduction - Nebius Token Factory documentation",
          "url": "https://docs.tokenfactory.nebius.com/api-reference/introduction"
        },
        {
          "date": "2026-02-11",
          "id": 22,
          "last_updated": "2026-02-16T16:36:30",
          "snippet": "",
          "source": "web",
          "title": "File-system conventions: proxy.js",
          "url": "https://nextjs.org/docs/app/api-reference/file-conventions/proxy"
        },
        {
          "date": "2026-02-14",
          "id": 23,
          "last_updated": "2026-02-15T15:47:39",
          "snippet": "",
          "source": "web",
          "title": "Migrating to the SSR package from Auth Helpers | Supabase Docs",
          "url": "https://supabase.com/docs/guides/auth/server-side/migrating-to-ssr-from-auth-helpers"
        },
        {
          "id": 24,
          "last_updated": "2026-02-15T00:19:07",
          "snippet": "",
          "source": "web",
          "title": "Nebius Token Factory | Models | Mastra Docs",
          "url": "https://mastra.ai/models/providers/nebius"
        },
        {
          "date": "2025-10-21",
          "id": 25,
          "last_updated": "2026-02-16T05:54:34",
          "snippet": "",
          "source": "web",
          "title": "Next.js 16",
          "url": "https://nextjs.org/blog/next-16"
        },
        {
          "date": "2024-02-15",
          "id": 26,
          "last_updated": "2025-10-03T21:03:26.689565",
          "snippet": "",
          "source": "web",
          "title": "using @supabase/ssr clients with nextjs #21303",
          "url": "https://github.com/orgs/supabase/discussions/21303"
        },
        {
          "id": 27,
          "last_updated": "2025-11-17T19:21:56.390819",
          "snippet": "",
          "source": "web",
          "title": "Nebius Token Factory | Models",
          "url": "https://mastra.ai/models/v1/providers/nebius"
        },
        {
          "date": "2025-10-12",
          "id": 28,
          "last_updated": "2026-02-03T02:03:47.736027",
          "snippet": "- Middleware acts as a gatekeeper for your entire application\n\n- You define protected routes once at the top level\n\n- If a request makes it past middleware, it's considered safe\n\n- All your auth logic lives in one centralized file\n\n**The New Mental Model:**\n\n- Proxy handles routing, rewrites, and redirects only\n\n- Authentication and authorization happen at the data layer\n\n- Every protected resource verifies access independently\n\n- Security checks live alongside the code they protect\n\n\u2026\n\n## What This Means for the Next.js Ecosystem\n\nWhether you agree with the approach or not, this shift will reshape how we build Next.js applications. Auth libraries like NextAuth (now Auth.js), Clerk, and custom solutions will need to adapt their patterns away from middleware-first approaches.\n\nWe'll see more tutorials teaching \"verify at the data layer\" as the primary pattern. New developers learning Next.js won't even think about putting auth in middleware\u2014they'll learn to verify sessions in their server actions and API routes from day one.\nThe\n\n`proxy.ts` file will become what Next.js always intended it to be: a place for routing logic, URL rewrites, and redirects. Not a security mechanism, but a traffic routing layer.\n\nThis will likely make Next.js applications more secure by default, even if the path to get there feels awkward. By forcing developers to be explicit about security at every access point, Next.js reduces the risk of forgotten checks or bypassed protections.",
          "source": "web",
          "title": "What Next.js is Actually Trying...",
          "url": "https://www.buildwithmatija.com/blog/nextjs16-middleware-change"
        },
        {
          "date": "2025-05-14",
          "id": 29,
          "last_updated": "2025-05-31T03:39:27.904470",
          "snippet": "",
          "source": "web",
          "title": "Issues \u00b7 supabase/ssr",
          "url": "https://github.com/supabase/ssr/issues"
        },
        {
          "date": "2025-11-11",
          "id": 30,
          "last_updated": "2025-12-01T03:54:53.224271",
          "snippet": "\ud83e\uddd1\ud83c\udffc\u200d\ud83d\udcbbSOME INFO\n\nNebius Token Factory: An OpenAI-compatible inference platform that lets developers deploy, fine-tune, and scale open-source LLMs effortlessly. Features include batch inference, custom fine-tuning, and native integrations with AI agent frameworks.\n\nHugging Face & OpenRouter Support: Nebius-hosted models are also available through Hugging Face and OpenRouter, making it easy to integrate into existing workflows or try models without switching platforms.",
          "source": "web",
          "title": "Exploring Nebius Token Factory | Open LLMs, AI Agents, Batch Inference, Fine-Tuning and more...",
          "url": "https://www.youtube.com/watch?v=Qfh4SdaLhNY"
        }
      ],
      "type": "search_results"
    },
    {
      "contents": [
        {
          "snippet": "Creating a Supabase client for SSR\n\nConfigure your Supabase client to use cookies\n\nTo use Server-Side Rendering (SSR) with Supabase, you need to configure your Supabase client to use cookies. The\n\n`@supabase/ssr` package helps you do this for JavaScript/TypeScript applications.\n\n## Install\n\nInstall the\n\n`@supabase/supabase-js` and\n\n`@supabase/ssr` helper packages:\n\n`1npm install @supabase/supabase-js @supabase/ssr`\n\n## Set environment variables\n\nCreate a\n\n`.env.local` file in the project root directory. In the file, set the project's Supabase URL and Key:\n\n###### Project URL\n\n###### Publishable key\n\n###### Anon key\n\nYou can also get the Project URL and key from the project's\n\n**Connect** dialog.\n\n##### Changes to API keys\n\nSupabase is changing the way keys work to improve project security and developer experience. You can read the full announcement, but in the transition period, you can use both the current\n\n`anon` and\n\n`service_role` keys and the new publishable key with the form\n\n`sb_publishable_xxx` which will replace the older keys.\n\nIn most cases, you can get the correct key from the Project's\n\n**Connect** dialog, but if you want a specific key, you can find all keys in the API Keys section of a Project's Settings page: **For legacy keys**, copy the\n\n`anon`key for client-side operations and the\n\n`service_role`key for server-side operations from the\n\n**Legacy API Keys**tab. **For new keys**, open the **API Keys**tab, if you don't have a publishable key already, click **Create new API Keys**, and copy the value from the **Publishable key**section.\n\nRead the API keys docs for a full explanation of all key types and their uses.\n\n`1NEXT_PUBLIC_SUPABASE_URL=supabase_project_url2NEXT_PUBLIC_SUPABASE_PUBLISHABLE_KEY=supabase_publishable_key`\n\n## Create a client\n\nYou need setup code to configure a Supabase client to use cookies. Once you have the utility code, you can use the\n\n`createClient` utility functions to get a properly configured Supabase client.\n\nUse the browser client in code that runs on the browser, and the server client in code that runs on the server.\n\n### Write utility functions to create Supabase clients\n\nTo access Supabase from a Next.js app, you need 2 types of Supabase clients:\n\n**Client Component client**- To access Supabase from Client Components, which run in the browser. **Server Component client**- To access Supabase from Server Components, Server Actions, and Route Handlers, which run only on the server.\n\nSince Next.js Server Components can't write cookies, you need a Proxy to refresh expired Auth tokens and store them.\n\nThe Proxy is responsible for:\n\n- Refreshing the Auth token by calling\n\n`supabase.auth.getClaims()`.\n\n- Passing the refreshed Auth token to Server Components, so they don't attempt to refresh the same token themselves. This is accomplished with\n\n`request.cookies.set`.\n\n- Passing the refreshed Auth token to the browser, so it replaces the old token. This is accomplished with\n\n`response.cookies.set`.\n\nCreate a\n\n`lib/supabase` folder at the root of your project, or inside the\n\n`./src` folder if you are using one, with a file for each type of client. Then copy the lib utility functions for each client type.\n\nView source\n\n`1import { createBrowserClient } from '@supabase/ssr'23export function createClient() {4 return createBrowserClient(5 process.env.NEXT_PUBLIC_SUPABASE_URL!,6 process.env.NEXT_PUBLIC_SUPABASE_PUBLISHABLE_KEY!7 )8}`\n\n### Hook up proxy\n\nThe code adds a matcher so the Proxy doesn't run on routes that don't access Supabase.\n\nBe careful when protecting pages. The server gets the user session from the cookies, which can be spoofed by anyone.\n\nAlways use\n\n`supabase.auth.getClaims()` to protect pages and user data.\n\n*Never* trust\n\n`supabase.auth.getSession()` inside server code such as Proxy. It isn't guaranteed to revalidate the Auth token.\n\nIt's safe to trust\n\n`getClaims()` because it validates the JWT signature against the project's published public keys every time.\n\nView source\n\n`1import { type NextRequest } from \"next/server\"2import { updateSession } from \"@/lib/supabase/proxy\"34export async function proxy(request: NextRequest) {5 return await updateSession(request)6}78export const config = {9 matcher: [10 /*11 * Match all request paths except for the ones starting with:12 * - _next/static (static files)13 * - _next/image (image optimization files)14 * - favicon.ico (favicon file)15 * Feel free to modify this pattern to include more paths.16 */17 \"/((?!_next/static|_next/image|favicon.ico|.*\\\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)\",18 ],19}`\n\n## Congratulations\n\nYou're done! To recap, you've successfully:\n\n- Called Supabase from a Server Action.\n\n- Called Supabase from a Server Component.\n\n- Set up a Supabase client utility to call Supabase from a Client Component. You can use this if you need to call Supabase from a Client Component, for example to set up a realtime subscription.\n\n- Set up Proxy to automatically refresh the Supabase Auth session.\n\nYou can now use any Supabase features from your client or server code!\n\n## Next steps\n\n- Implement Authentication using Email and Password\n\n- Implement Authentication using OAuth\n\n- Learn more about SSR\n\n",
          "title": "Creating a Supabase client for SSR",
          "url": "https://supabase.com/docs/guides/auth/server-side/creating-a-client"
        },
        {
          "snippet": "Here are examples of Python, cURL and JavaScript SDK command that makes an API request from your terminal:\n\nNebius Token Factory offers an OpenAI-compatible API for inference and fine-tuning.\n\n```\n\nimport os\n\nfrom openai import OpenAI\n\nclient = OpenAI(\n\nbase_url=\"https://api.tokenfactory.nebius.com/v1/\",\n\napi_key=os.environ.get(\"NEBIUS_API_KEY\"),\n\n\n\ncompletion = client.chat.completions.create(\n\nmodel=\"meta-llama/Meta-Llama-3.1-70B-Instruct\",\n\nmessages=[\n\n\n\n\"role\": \"user\",\n\n\"content\": \"\"\"Hello!\"\"\"\n\n\n\n],\n\ntemperature=0.6\n\n\n\nprint(completion.to_json())\n\n```\n\nFor more examples, see Examples of using the Nebius Token Factory API.\n\nResponse\n\nResponse\n\n```\n\n\n\n\"choices\": [\n\n\n\n\"finish_reason\": \"stop\",\n\n\"index\": 0,\n\n\"message\": {\n\n\"content\": \"Hello! It's nice to meet you. Is there something I can help you with, or would you like to chat?\",\n\n\"role\": \"assistant\"\n\n\n\n],\n\n\"created\": 1717516032,\n\n\"model\": \"meta-llama/Meta-Llama-3-70B-Instruct-cheap\",\n\n\"object\": \"chat.completion\",\n\n\"usage\": {\n\n\"completion_tokens\": 26,\n\n\"prompt_tokens\": 13,\n\n\"total_tokens\": 39\n\n\n\n```\n\n## AuthenticationTo authenticate, include your\n\n*API key*(e.g.,\n\n`ABC123...`) in the\n\n`Authorization` header, as shown below:\n\nTo get an API key:\n\n```\n\nAuthorization: Bearer ABC123...\n\n```\n\n- In Nebius Token Factory, go to the API keys section.\n\n- Click\n\n**Create API key**.\n\n- Enter the key name and then click\n\n**Create**.\n\n- Save the displayed API key. You cannot open it later in Nebius Token Factory.\n\n",
          "title": "Introduction - Nebius Token Factory documentation",
          "url": "https://docs.tokenfactory.nebius.com/api-reference/introduction"
        }
      ],
      "type": "fetch_url_results"
    },
    {
      "contents": [
        {
          "snippet": "Migrating to the SSR package from Auth Helpers\n\nThe new\n\n`ssr` package takes the core concepts of the Auth Helpers and makes them available to any server language or framework. This page will guide you through migrating from the Auth Helpers package to\n\n`ssr`.\n\n## Replacing Supabase packages\n\n`1npm uninstall @supabase/auth-helpers-nextjs`\n\n`1npm install @supabase/ssr`\n\n## Creating a client\n\nThe new\n\n`ssr` package exports two functions for creating a Supabase client. The\n\n`createBrowserClient` function is used in the client, and the\n\n`createServerClient` function is used in the server.\n\nRead the Creating a client page for examples of creating a client in your framework and our migration guide.\n\n## Next steps\n\n- Implement Authentication using Email and Password\n\n- Implement Authentication using OAuth\n\n- Learn more about SSR\n\n",
          "title": "Migrating to the SSR package from Auth Helpers | Supabase Docs",
          "url": "https://supabase.com/docs/guides/auth/server-side/migrating-to-ssr-from-auth-helpers"
        },
        {
          "snippet": "Welcome to the Advanced Server Rendering guide, where you will learn all about using React Query with streaming, Server Components and the Next.js app router.\n\nYou might want to read the Server Rendering & Hydration guide before this one as it teaches the basics for using React Query with SSR, and Performance & Request Waterfalls as well as Prefetching & Router Integration also contains valuable background.\n\nBefore we start, let's note that while the initialData approach outlined in the SSR guide also works with Server Components, we'll focus this guide on the hydration APIs.\n\nWe won't cover Server Components in depth here, but the short version is that they are components that are guaranteed to\n\n*only* run on the server, both for the initial page view and **also on page transitions**. This is similar to how Next.js getServerSideProps/getStaticProps and Remix loader works, as these also always run on the server but while those can only return data, Server Components can do a lot more. The data part is central to React Query however, so let's focus on that.\n\nHow do we take what we learned in the Server Rendering guide about passing data prefetched in framework loaders to the app and apply that to Server Components and the Next.js app router? The best way to start thinking about this is to consider Server Components as \"just\" another framework loader.\n\nSo far in these guides, we've been talking about the\n\n*server* and the *client*. It's important to note that confusingly enough this does not match 1-1 with *Server Components* and *Client Components*. Server Components are guaranteed to only run on the server, but Client Components can actually run in both places. The reason for this is that they can also render during the initial *server rendering* pass.\n\nOne way to think of this is that even though Server Components also\n\n*render*, they happen during a \"loader phase\" (always happens on the server), while Client Components run during the \"application phase\". That application can run both on the server during SSR, and in for example a browser. Where exactly that application runs and if it runs during SSR or not might differ between frameworks.\n\nThe first step of any React Query setup is always to create a queryClient and wrap your application in a QueryClientProvider. With Server Components, this looks mostly the same across frameworks, one difference being the filename conventions:\n\n```\n\n// In Next.js, this file would be called: app/providers.tsx\n\n'use client'\n\n// Since QueryClientProvider relies on useContext under the hood, we have to put 'use client' on top\n\nimport {\n\nisServer,\n\nQueryClient,\n\nQueryClientProvider,\n\n} from '@tanstack/react-query'\n\nfunction makeQueryClient() {\n\nreturn new QueryClient({\n\ndefaultOptions: {\n\nqueries: {\n\n// With SSR, we usually want to set some default staleTime\n\n// above 0 to avoid refetching immediately on the client\n\nstaleTime: 60 * 1000,\n\n},\n\n},\n\n})\n\n\n\nlet browserQueryClient: QueryClient | undefined = undefined\n\nfunction getQueryClient() {\n\nif (isServer) {\n\n// Server: always make a new query client\n\nreturn makeQueryClient()\n\n} else {\n\n// Browser: make a new query client if we don't already have one\n\n// This is very important, so we don't re-make a new client if React\n\n// suspends during the initial render. This may not be needed if we\n\n// have a suspense boundary BELOW the creation of the query client\n\nif (!browserQueryClient) browserQueryClient = makeQueryClient()\n\nreturn browserQueryClient\n\n\n\nexport default function Providers({ children }: { children: React.ReactNode }) {\n\n// NOTE: Avoid useState when initializing the query client if you don't\n\n// have a suspense boundary between this and the code that may\n\n// suspend because React will throw away the client on the initial\n\n// render if it suspends and there is no boundary\n\nconst queryClient = getQueryClient()\n\nreturn (\n\n<QueryClientProvider client={queryClient}>{children}</QueryClientProvider>\n\n\n\n```\n\n```\n\n// In Next.js, this file would be called: app/providers.tsx\n\n'use client'\n\n// Since QueryClientProvider relies on useContext under the hood, we have to put 'use client' on top\n\nimport {\n\nisServer,\n\nQueryClient,\n\nQueryClientProvider,\n\n} from '@tanstack/react-query'\n\nfunction makeQueryClient() {\n\nreturn new QueryClient({\n\ndefaultOptions: {\n\nqueries: {\n\n// With SSR, we usually want to set some default staleTime\n\n// above 0 to avoid refetching immediately on the client\n\nstaleTime: 60 * 1000,\n\n},\n\n},\n\n})\n\n\n\nlet browserQueryClient: QueryClient | undefined = undefined\n\nfunction getQueryClient() {\n\nif (isServer) {\n\n// Server: always make a new query client\n\nreturn makeQueryClient()\n\n} else {\n\n// Browser: make a new query client if we don't already have one\n\n// This is very important, so we don't re-make a new client if React\n\n// suspends during the initial render. This may not be needed if we\n\n// have a suspense boundary BELOW the creation of the query client\n\nif (!browserQueryClient) browserQueryClient = makeQueryClient()\n\nreturn browserQueryClient\n\n\n\nexport default function Providers({ children }: { children: React.ReactNode }) {\n\n// NOTE: Avoid useState when initializing the query client if you don't\n\n// have a suspense boundary between this and the code that may\n\n// suspend because React will throw away the client on the initial\n\n// render if it suspends and there is no boundary\n\nconst queryClient = getQueryClient()\n\nreturn (\n\n<QueryClientProvider client={queryClient}>{children}</QueryClientProvider>\n\n\n\n```\n\n```\n\n// In Next.js, this file would be called: app/layout.tsx\n\nimport Providers from './providers'\n\nexport default function RootLayout({\n\nchildren,\n\n}: {\n\nchildren: React.ReactNode\n\n}) {\n\nreturn (\n\n<html lang=\"en\">\n\n<head />\n\n<body>\n\n<Providers>{children}</Providers>\n\n</body>\n\n</html>\n\n\n\n```\n\n```\n\n// In Next.js, this file would be called: app/layout.tsx\n\nimport Providers from './providers'\n\nexport default function RootLayout({\n\nchildren,\n\n}: {\n\nchildren: React.ReactNode\n\n}) {\n\nreturn (\n\n<html lang=\"en\">\n\n<head />\n\n<body>\n\n<Providers>{children}</Providers>\n\n</body>\n\n</html>\n\n\n\n```\n\nThis part is pretty similar to what we did in the SSR guide, we just need to split things up into two different files.\n\nNext, let\u2019s look at how to actually prefetch data, then dehydrate and hydrate it. This is what it looked like using the\n\n**Next.js Pages Router**:\n\n```\n\n// pages/posts.tsx\n\nimport {\n\ndehydrate,\n\nHydrationBoundary,\n\nQueryClient,\n\nuseQuery,\n\n} from '@tanstack/react-query'\n\n// This could also be getServerSideProps\n\nexport async function getStaticProps() {\n\nconst queryClient = new QueryClient()\n\nawait queryClient.prefetchQuery({\n\nqueryKey: ['posts'],\n\nqueryFn: getPosts,\n\n})\n\nreturn {\n\nprops: {\n\ndehydratedState: dehydrate(queryClient),\n\n},\n\n\n\nfunction Posts() {\n\n// This useQuery could just as well happen in some deeper child to\n\n// the <PostsRoute>, data will be available immediately either way\n\n//\n\n// Note that we are using useQuery here instead of useSuspenseQuery.\n\n// Because this data has already been prefetched, there is no need to\n\n// ever suspend in the component itself. If we forget or remove the\n\n// prefetch, this will instead fetch the data on the client, while\n\n// using useSuspenseQuery would have had worse side effects.\n\nconst { data } = useQuery({ queryKey: ['posts'], queryFn: getPosts })\n\n// This query was not prefetched on the server and will not start\n\n// fetching until on the client, both patterns are fine to mix\n\nconst { data: commentsData } = useQuery({\n\nqueryKey: ['posts-comments'],\n\nqueryFn: getComments,\n\n})\n\n// ...\n\n\n\nexport default function PostsRoute({ dehydratedState }) {\n\nreturn (\n\n<HydrationBoundary state={dehydratedState}>\n\n<Posts />\n\n</HydrationBoundary>\n\n\n\n```\n\n```\n\n// pages/posts.tsx\n\nimport {\n\ndehydrate,\n\nHydrationBoundary,\n\nQueryClient,\n\nuseQuery,\n\n} from '@tanstack/react-query'\n\n// This could also be getServerSideProps\n\nexport async function getStaticProps() {\n\nconst queryClient = new QueryClient()\n\nawait queryClient.prefetchQuery({\n\nqueryKey: ['posts'],\n\nqueryFn: getPosts,\n\n})\n\nreturn {\n\nprops: {\n\ndehydratedState: dehydrate(queryClient),\n\n},\n\n\n\nfunction Posts() {\n\n// This useQuery could just as well happen in some deeper child to\n\n// the <PostsRoute>, data will be available immediately either way\n\n//\n\n// Note that we are using useQuery here instead of useSuspenseQuery.\n\n// Because this data has already been prefetched, there is no need to\n\n// ever suspend in the component itself. If we forget or remove the\n\n// prefetch, this will instead fetch the data on the client, while\n\n// using useSuspenseQuery would have had worse side effects.\n\nconst { data } = useQuery({ queryKey: ['posts'], queryFn: getPosts })\n\n// This query was not prefetched on the server and will not start\n\n// fetching until on the client, both patterns are fine to mix\n\nconst { data: commentsData } = useQuery({\n\nqueryKey: ['posts-comments'],\n\nqueryFn: getComments,\n\n})\n\n// ...\n\n\n\nexport default function PostsRoute({ dehydratedState }) {\n\nreturn (\n\n<HydrationBoundary state={dehydratedState}>\n\n<Posts />\n\n</HydrationBoundary>\n\n\n\n```\n\nConverting this to the app router actually looks pretty similar, we just need to move things around a bit. First, we'll create a Server Component to do the prefetching part:\n\n```\n\n// app/posts/page.tsx\n\nimport {\n\ndehydrate,\n\nHydrationBoundary,\n\nQueryClient,\n\n} from '@tanstack/react-query'\n\nimport Posts from './posts'\n\nexport default async function PostsPage() {\n\nconst queryClient = new QueryClient()\n\nawait queryClient.prefetchQuery({\n\nqueryKey: ['posts'],\n\nqueryFn: getPosts,\n\n})\n\nreturn (\n\n// Neat! Serialization is now as easy as passing props.\n\n// HydrationBoundary is a Client Component, so hydration will happen there.\n\n<HydrationBoundary state={dehydrate(queryClient)}>\n\n<Posts />\n\n</HydrationBoundary>\n\n\n\n```\n\n```\n\n// app/posts/page.tsx\n\nimport {\n\ndehydrate,\n\nHydrationBoundary,\n\nQueryClient,\n\n} from '@tanstack/react-query'\n\nimport Posts from './posts'\n\nexport default async function PostsPage() {\n\nconst queryClient = new QueryClient()\n\nawait queryClient.prefetchQuery({\n\nqueryKey: ['posts'],\n\nqueryFn: getPosts,\n\n})\n\nreturn (\n\n// Neat! Serialization is now as easy as passing props.\n\n// HydrationBoundary is a Client Component, so hydration will happen there.\n\n<HydrationBoundary state={dehydrate(queryClient)}>\n\n<Posts />\n\n</HydrationBoundary>\n\n\n\n```\n\nNext, we'll look at what the Client Component part looks like:\n\n```\n\n// app/posts/posts.tsx\n\n'use client'\n\nexport default function Posts() {\n\n// This useQuery could just as well happen in some deeper\n\n// child to <Posts>, data will be available immediately either way\n\nconst { data } = useQuery({\n\nqueryKey: ['posts'],\n\nqueryFn: () => getPosts(),\n\n})\n\n// This query was not prefetched on the server and will not start\n\n// fetching until on the client, both patterns are fine to mix.\n\nconst { data: commentsData } = useQuery({\n\nqueryKey: ['posts-comments'],\n\nqueryFn: getComments,\n\n})\n\n// ...\n\n\n\n```\n\n```\n\n// app/posts/posts.tsx\n\n'use client'\n\nexport default function Posts() {\n\n// This useQuery could just as well happen in some deeper\n\n// child to <Posts>, data will be available immediately either way\n\nconst { data } = useQuery({\n\nqueryKey: ['posts'],\n\nqueryFn: () => getPosts(),\n\n})\n\n// This query was not prefetched on the server and will not start\n\n// fetching until on the client, both patterns are fine to mix.\n\nconst { data: commentsData } = useQuery({\n\nqueryKey: ['posts-comments'],\n\nqueryFn: getComments,\n\n})\n\n// ...\n\n\n\n```\n\nOne neat thing about the examples above is that the only thing that is Next.js-specific here are the file names, everything else would look the same in any other framework that supports Server Components.\n\nIn the SSR guide, we noted that you could get rid of the boilerplate of having <HydrationBoundary> in every route. This is not possible with Server Components.\n\nNOTE: If you encounter a type error while using async Server Components with TypeScript versions lower than 5.1.3 and @types/react versions lower than 18.2.8, it is recommended to update to the latest versions of both. Alternatively, you can use the temporary workaround of adding {/* @ts-expect-error Server Component */} when calling this component inside another. For more information, see Async Server Component TypeScript Error in the Next.js 13 docs.\n\nNOTE: If you encounter an error Only plain objects, and a few built-ins, can be passed to Server Actions. Classes or null prototypes are not supported. make sure that you're\n\nnotpassing to queryFn a function reference, instead call the function because queryFn args has a bunch of properties and not all of it would be serializable. see Server Action only works when queryFn isn't a reference.\n\nA nice thing about Server Components is that they can be nested and exist on many levels in the React tree, making it possible to prefetch data closer to where it's actually used instead of only at the top of the application (just like Remix loaders). This can be as simple as a Server Component rendering another Server Component (we'll leave the Client Components out in this example for brevity):\n\n```\n\n// app/posts/page.tsx\n\nimport {\n\ndehydrate,\n\nHydrationBoundary,\n\nQueryClient,\n\n} from '@tanstack/react-query'\n\nimport Posts from './posts'\n\nimport CommentsServerComponent from './comments-server'\n\nexport default async function PostsPage() {\n\nconst queryClient = new QueryClient()\n\nawait queryClient.prefetchQuery({\n\nqueryKey: ['posts'],\n\nqueryFn: getPosts,\n\n})\n\nreturn (\n\n<HydrationBoundary state={dehydrate(queryClient)}>\n\n<Posts />\n\n<CommentsServerComponent />\n\n</HydrationBoundary>\n\n\n\n// app/posts/comments-server.tsx\n\nimport {\n\ndehydrate,\n\nHydrationBoundary,\n\nQueryClient,\n\n} from '@tanstack/react-query'\n\nimport Comments from './comments'\n\nexport default async function CommentsServerComponent() {\n\nconst queryClient = new QueryClient()\n\nawait queryClient.prefetchQuery({\n\nqueryKey: ['posts-comments'],\n\nqueryFn: getComments,\n\n})\n\nreturn (\n\n<HydrationBoundary state={dehydrate(queryClient)}>\n\n<Comments />\n\n</HydrationBoundary>\n\n\n\n```\n\n```\n\n// app/posts/page.tsx\n\nimport {\n\ndehydrate,\n\nHydrationBoundary,\n\nQueryClient,\n\n} from '@tanstack/react-query'\n\nimport Posts from './posts'\n\nimport CommentsServerComponent from './comments-server'\n\nexport default async function PostsPage() {\n\nconst queryClient = new QueryClient()\n\nawait queryClient.prefetchQuery({\n\nqueryKey: ['posts'],\n\nqueryFn: getPosts,\n\n})\n\nreturn (\n\n<HydrationBoundary state={dehydrate(queryClient)}>\n\n<Posts />\n\n<CommentsServerComponent />\n\n</HydrationBoundary>\n\n\n\n// app/posts/comments-server.tsx\n\nimport {\n\ndehydrate,\n\nHydrationBoundary,\n\nQueryClient,\n\n} from '@tanstack/react-query'\n\nimport Comments from './comments'\n\nexport default async function CommentsServerComponent() {\n\nconst queryClient = new QueryClient()\n\nawait queryClient.prefetchQuery({\n\nqueryKey: ['posts-comments'],\n\nqueryFn: getComments,\n\n})\n\nreturn (\n\n<HydrationBoundary state={dehydrate(queryClient)}>\n\n<Comments />\n\n</HydrationBoundary>\n\n\n\n```\n\nAs you can see, it's perfectly fine to use <HydrationBoundary> in multiple places, and create and dehydrate multiple queryClient for prefetching.\n\nNote that because we are awaiting getPosts before rendering CommentsServerComponent this would lead to a server side waterfall:\n\n```\n\n1. |> getPosts()\n\n2. |> getComments()\n\n```\n\n```\n\n1. |> getPosts()\n\n2. |> getComments()\n\n```\n\nIf the server latency to the data is low, this might not be a huge issue, but is still worth pointing out.\n\nIn Next.js, besides prefetching data in page.tsx, you can also do it in layout.tsx, and in parallel routes. Because these are all part of the routing, Next.js knows how to fetch them all in parallel. So if CommentsServerComponent above was instead expressed as a parallel route, the waterfall would be flattened automatically.\n\nAs more frameworks start supporting Server Components, they might have other routing conventions. Read your framework docs for details.\n\nIn the example above, we create a new queryClient for each Server Component that fetches data. This is the recommended approach, but if you want to, you can alternatively create a single one that is reused across all Server Components:\n\n```\n\n// app/getQueryClient.tsx\n\nimport { QueryClient } from '@tanstack/react-query'\n\nimport { cache } from 'react'\n\n// cache() is scoped per request, so we don't leak data between requests\n\nconst getQueryClient = cache(() => new QueryClient())\n\nexport default getQueryClient\n\n```\n\n```\n\n// app/getQueryClient.tsx\n\nimport { QueryClient } from '@tanstack/react-query'\n\nimport { cache } from 'react'\n\n// cache() is scoped per request, so we don't leak data between requests\n\nconst getQueryClient = cache(() => new QueryClient())\n\nexport default getQueryClient\n\n```\n\nThe benefit of this is that you can call getQueryClient() to get a hold of this client anywhere that gets called from a Server Component, including utility functions. The downside is that every time you call dehydrate(getQueryClient()), you serialize\n\n*the entire* queryClient, including queries that have already been serialized before and are unrelated to the current Server Component which is unnecessary overhead.\n\nNext.js already dedupes requests that utilize fetch(), but if you are using something else in your queryFn, or if you use a framework that does\n\n*not* dedupe these requests automatically, using a single queryClient as described above might make sense, despite the duplicated serialization.\n\nAs a future improvement, we might look into creating a dehydrateNew() function (name pending) that only dehydrate queries that are\n\nnewsince the last call to dehydrateNew(). Feel free to get in touch if this sounds interesting and like something you want to help out with!\n\nWith Server Components, it's important to think about data ownership and revalidation. To explain why, let's look at a modified example from above:\n\n```\n\n// app/posts/page.tsx\n\nimport {\n\ndehydrate,\n\nHydrationBoundary,\n\nQueryClient,\n\n} from '@tanstack/react-query'\n\nimport Posts from './posts'\n\nexport default async function PostsPage() {\n\nconst queryClient = new QueryClient()\n\n// Note we are now using fetchQuery()\n\nconst posts = await queryClient.fetchQuery({\n\nqueryKey: ['posts'],\n\nqueryFn: getPosts,\n\n})\n\nreturn (\n\n<HydrationBoundary state={dehydrate(queryClient)}>\n\n{/* This is the new part */}\n\n<div>Nr of posts: {posts.length}</div>\n\n<Posts />\n\n</HydrationBoundary>\n\n\n\n```\n\n```\n\n// app/posts/page.tsx\n\nimport {\n\ndehydrate,\n\nHydrationBoundary,\n\nQueryClient,\n\n} from '@tanstack/react-query'\n\nimport Posts from './posts'\n\nexport default async function PostsPage() {\n\nconst queryClient = new QueryClient()\n\n// Note we are now using fetchQuery()\n\nconst posts = await queryClient.fetchQuery({\n\nqueryKey: ['posts'],\n\nqueryFn: getPosts,\n\n})\n\nreturn (\n\n<HydrationBoundary state={dehydrate(queryClient)}>\n\n{/* This is the new part */}\n\n<div>Nr of posts: {posts.length}</div>\n\n<Posts />\n\n</HydrationBoundary>\n\n\n\n```\n\nWe are now rendering data from the getPosts query both in a Server Component and in a Client Component. This will be fine for the initial page render, but what happens when the query revalidates on the client for some reason when staleTime has been passed?\n\nReact Query has no idea of how to\n\n*revalidate the Server Component*, so if it refetches the data on the client, causing React to rerender the list of posts, the Nr of posts: {posts.length} will end up out of sync.\n\nThis is fine if you set staleTime: Infinity, so that React Query never revalidates, but this is probably not what you want if you are using React Query in the first place.\n\nUsing React Query with Server Components makes most sense if:\n\nIt's hard to give general advice on when it makes sense to pair React Query with Server Components and not.\n\n**If you are just starting out with a new Server Components app, we suggest you start out with any tools for data fetching your framework provides you with and avoid bringing in React Query until you actually need it.** This might be never, and that's fine, use the right tool for the job!\n\nIf you do use it, a good rule of thumb is to avoid queryClient.fetchQuery unless you need to catch errors. If you do use it, don't render its result on the server or pass the result to another component, even a Client Component one.\n\nFrom the React Query perspective, treat Server Components as a place to prefetch data, nothing more.\n\nOf course, it's fine to have Server Components own some data, and Client Components own other, just make sure those two realities don't get out of sync.\n\nThe Next.js app router automatically streams any part of the application that is ready to be displayed to the browser as soon as possible, so finished content can be displayed immediately without waiting for still pending content. It does this along <Suspense> boundary lines. Note that if you create a file loading.tsx, this automatically creates a <Suspense> boundary behind the scenes.\n\nWith the prefetching patterns described above, React Query is perfectly compatible with this form of streaming. As the data for each Suspense boundary resolves, Next.js can render and stream the finished content to the browser. This works even if you are using useQuery as outlined above because the suspending actually happens when you await the prefetch.\n\nAs of React Query v5.40.0, you don't have to await all prefetches for this to work, as pending Queries can also be dehydrated and sent to the client. This lets you kick off prefetches as early as possible without letting them block an entire Suspense boundary, and streams the\n\n*data* to the client as the query finishes. This can be useful for example if you want to prefetch some content that is only visible after some user interaction, or say if you want to await and render the first page of an infinite query, but start prefetching page 2 without blocking rendering.\n\nTo make this work, we have to instruct the queryClient to also dehydrate pending Queries. We can do this globally, or by passing that option directly to dehydrate.\n\nWe will also need to move the getQueryClient() function out of our app/providers.tsx file as we want to use it in our server component and our client provider.\n\n```\n\n// app/get-query-client.ts\n\nimport {\n\nisServer,\n\nQueryClient,\n\ndefaultShouldDehydrateQuery,\n\n} from '@tanstack/react-query'\n\nfunction makeQueryClient() {\n\nreturn new QueryClient({\n\ndefaultOptions: {\n\nqueries: {\n\nstaleTime: 60 * 1000,\n\n},\n\ndehydrate: {\n\n// include pending queries in dehydration\n\nshouldDehydrateQuery: (query) =>\n\ndefaultShouldDehydrateQuery(query) ||\n\nquery.state.status === 'pending',\n\nshouldRedactErrors: (error) => {\n\n// We should not catch Next.js server errors\n\n// as that's how Next.js detects dynamic pages\n\n// so we cannot redact them.\n\n// Next.js also automatically redacts errors for us\n\n// with better digests.\n\nreturn false\n\n},\n\n},\n\n},\n\n})\n\n\n\nlet browserQueryClient: QueryClient | undefined = undefined\n\nexport function getQueryClient() {\n\nif (isServer) {\n\n// Server: always make a new query client\n\nreturn makeQueryClient()\n\n} else {\n\n// Browser: make a new query client if we don't already have one\n\n// This is very important, so we don't re-make a new client if React\n\n// suspends during the initial render. This may not be needed if we\n\n// have a suspense boundary BELOW the creation of the query client\n\nif (!browserQueryClient) browserQueryClient = makeQueryClient()\n\nreturn browserQueryClient\n\n\n\n```\n\n```\n\n// app/get-query-client.ts\n\nimport {\n\nisServer,\n\nQueryClient,\n\ndefaultShouldDehydrateQuery,\n\n} from '@tanstack/react-query'\n\nfunction makeQueryClient() {\n\nreturn new QueryClient({\n\ndefaultOptions: {\n\nqueries: {\n\nstaleTime: 60 * 1000,\n\n},\n\ndehydrate: {\n\n// include pending queries in dehydration\n\nshouldDehydrateQuery: (query) =>\n\ndefaultShouldDehydrateQuery(query) ||\n\nquery.state.status === 'pending',\n\nshouldRedactErrors: (error) => {\n\n// We should not catch Next.js server errors\n\n// as that's how Next.js detects dynamic pages\n\n// so we cannot redact them.\n\n// Next.js also automatically redacts errors for us\n\n// with better digests.\n\nreturn false\n\n},\n\n},\n\n},\n\n})\n\n\n\nlet browserQueryClient: QueryClient | undefined = undefined\n\nexport function getQueryClient() {\n\nif (isServer) {\n\n// Server: always make a new query client\n\nreturn makeQueryClient()\n\n} else {\n\n// Browser: make a new query client if we don't already have one\n\n// This is very important, so we don't re-make a new client if React\n\n// suspends during the initial render. This may not be needed if we\n\n// have a suspense boundary BELOW the creation of the query client\n\nif (!browserQueryClient) browserQueryClient = makeQueryClient()\n\nreturn browserQueryClient\n\n\n\n```\n\nNote: This works in NextJs and Server Components because React can serialize Promises over the wire when you pass them down to Client Components.\n\nThen, all we need to do is provide a HydrationBoundary, but we don't need to await prefetches anymore:\n\n```\n\n// app/posts/page.tsx\n\nimport { dehydrate, HydrationBoundary } from '@tanstack/react-query'\n\nimport { getQueryClient } from './get-query-client'\n\nimport Posts from './posts'\n\n// the function doesn't need to be `async` because we don't `await` anything\n\nexport default function PostsPage() {\n\nconst queryClient = getQueryClient()\n\n// look ma, no await\n\nqueryClient.prefetchQuery({\n\nqueryKey: ['posts'],\n\nqueryFn: getPosts,\n\n})\n\nreturn (\n\n<HydrationBoundary state={dehydrate(queryClient)}>\n\n<Posts />\n\n</HydrationBoundary>\n\n\n\n```\n\n```\n\n// app/posts/page.tsx\n\nimport { dehydrate, HydrationBoundary } from '@tanstack/react-query'\n\nimport { getQueryClient } from './get-query-client'\n\nimport Posts from './posts'\n\n// the function doesn't need to be `async` because we don't `await` anything\n\nexport default function PostsPage() {\n\nconst queryClient = getQueryClient()\n\n// look ma, no await\n\nqueryClient.prefetchQuery({\n\nqueryKey: ['posts'],\n\nqueryFn: getPosts,\n\n})\n\nreturn (\n\n<HydrationBoundary state={dehydrate(queryClient)}>\n\n<Posts />\n\n</HydrationBoundary>\n\n\n\n```\n\nOn the client, the Promise will be put into the QueryCache for us. That means we can now call useSuspenseQuery inside the Posts component to \"use\" that Promise (which was created on the Server):\n\n```\n\n// app/posts/posts.tsx\n\n'use client'\n\nexport default function Posts() {\n\nconst { data } = useSuspenseQuery({ queryKey: ['posts'], queryFn: getPosts })\n\n// ...\n\n\n\n```\n\n```\n\n// app/posts/posts.tsx\n\n'use client'\n\nexport default function Posts() {\n\nconst { data } = useSuspenseQuery({ queryKey: ['posts'], queryFn: getPosts })\n\n// ...\n\n\n\n```\n\nNote that you could also useQuery instead of useSuspenseQuery, and the Promise would still be picked up correctly. However, NextJs won't suspend in that case and the component will render in the pending status, which also opts out of server rendering the content.\n\nIf you're using non-JSON data types and serialize the query results on the server, you can specify the dehydrate.serializeData and hydrate.deserializeData options to serialize and deserialize the data on each side of the boundary to ensure the data in the cache is the same format both on the server and the client:\n\n```\n\n// app/get-query-client.ts\n\nimport { QueryClient, defaultShouldDehydrateQuery } from '@tanstack/react-query'\n\nimport { deserialize, serialize } from './transformer'\n\nfunction makeQueryClient() {\n\nreturn new QueryClient({\n\ndefaultOptions: {\n\n// ...\n\nhydrate: {\n\ndeserializeData: deserialize,\n\n},\n\ndehydrate: {\n\nserializeData: serialize,\n\n},\n\n},\n\n})\n\n\n\n// ...\n\n```\n\n```\n\n// app/get-query-client.ts\n\nimport { QueryClient, defaultShouldDehydrateQuery } from '@tanstack/react-query'\n\nimport { deserialize, serialize } from './transformer'\n\nfunction makeQueryClient() {\n\nreturn new QueryClient({\n\ndefaultOptions: {\n\n// ...\n\nhydrate: {\n\ndeserializeData: deserialize,\n\n},\n\ndehydrate: {\n\nserializeData: serialize,\n\n},\n\n},\n\n})\n\n\n\n// ...\n\n```\n\n```\n\n// app/posts/page.tsx\n\nimport {\n\ndehydrate,\n\nHydrationBoundary,\n\nQueryClient,\n\n} from '@tanstack/react-query'\n\nimport { getQueryClient } from './get-query-client'\n\nimport { serialize } from './transformer'\n\nimport Posts from './posts'\n\nexport default function PostsPage() {\n\nconst queryClient = getQueryClient()\n\n// look ma, no await\n\nqueryClient.prefetchQuery({\n\nqueryKey: ['posts'],\n\nqueryFn: () => getPosts().then(serialize), // <-- serialize the data on the server\n\n})\n\nreturn (\n\n<HydrationBoundary state={dehydrate(queryClient)}>\n\n<Posts />\n\n</HydrationBoundary>\n\n\n\n```\n\n```\n\n// app/posts/page.tsx\n\nimport {\n\ndehydrate,\n\nHydrationBoundary,\n\nQueryClient,\n\n} from '@tanstack/react-query'\n\nimport { getQueryClient } from './get-query-client'\n\nimport { serialize } from './transformer'\n\nimport Posts from './posts'\n\nexport default function PostsPage() {\n\nconst queryClient = getQueryClient()\n\n// look ma, no await\n\nqueryClient.prefetchQuery({\n\nqueryKey: ['posts'],\n\nqueryFn: () => getPosts().then(serialize), // <-- serialize the data on the server\n\n})\n\nreturn (\n\n<HydrationBoundary state={dehydrate(queryClient)}>\n\n<Posts />\n\n</HydrationBoundary>\n\n\n\n```\n\n```\n\n// app/posts/posts.tsx\n\n'use client'\n\nexport default function Posts() {\n\nconst { data } = useSuspenseQuery({ queryKey: ['posts'], queryFn: getPosts })\n\n// ...\n\n\n\n```\n\n```\n\n// app/posts/posts.tsx\n\n'use client'\n\nexport default function Posts() {\n\nconst { data } = useSuspenseQuery({ queryKey: ['posts'], queryFn: getPosts })\n\n// ...\n\n\n\n```\n\nNow, your getPosts function can return e.g. Temporal datetime objects and the data will be serialized and deserialized on the client, assuming your transformer can serialize and deserialize those data types.\n\nFor more information, check out the Next.js App with Prefetching Example.\n\nWhile we recommend the prefetching solution detailed above because it flattens request waterfalls both on the initial page load\n\n**and** any subsequent page navigation, there is an experimental way to skip prefetching altogether and still have streaming SSR work: @tanstack/react-query-next-experimental\n\nThis package will allow you to fetch data on the server (in a Client Component) by just calling useSuspenseQuery in your component. Results will then be streamed from the server to the client as SuspenseBoundaries resolve. If you call useSuspenseQuery without wrapping it in a <Suspense> boundary, the HTML response won't start until the fetch resolves. This can be when you want depending on the situation, but keep in mind that this will hurt your TTFB.\n\nTo achieve this, wrap your app in the ReactQueryStreamedHydration component:\n\n```\n\n// app/providers.tsx\n\n'use client'\n\nimport {\n\nisServer,\n\nQueryClient,\n\nQueryClientProvider,\n\n} from '@tanstack/react-query'\n\nimport * as React from 'react'\n\nimport { ReactQueryStreamedHydration } from '@tanstack/react-query-next-experimental'\n\nfunction makeQueryClient() {\n\nreturn new QueryClient({\n\ndefaultOptions: {\n\nqueries: {\n\n// With SSR, we usually want to set some default staleTime\n\n// above 0 to avoid refetching immediately on the client\n\nstaleTime: 60 * 1000,\n\n},\n\n},\n\n})\n\n\n\nlet browserQueryClient: QueryClient | undefined = undefined\n\nfunction getQueryClient() {\n\nif (isServer) {\n\n// Server: always make a new query client\n\nreturn makeQueryClient()\n\n} else {\n\n// Browser: make a new query client if we don't already have one\n\n// This is very important, so we don't re-make a new client if React\n\n// suspends during the initial render. This may not be needed if we\n\n// have a suspense boundary BELOW the creation of the query client\n\nif (!browserQueryClient) browserQueryClient = makeQueryClient()\n\nreturn browserQueryClient\n\n\n\nexport function Providers(props: { children: React.ReactNode }) {\n\n// NOTE: Avoid useState when initializing the query client if you don't\n\n// have a suspense boundary between this and the code that may\n\n// suspend because React will throw away the client on the initial\n\n// render if it suspends and there is no boundary\n\nconst queryClient = getQueryClient()\n\nreturn (\n\n<QueryClientProvider client={queryClient}>\n\n<ReactQueryStreamedHydration>\n\n{props.children}\n\n</ReactQueryStreamedHydration>\n\n</QueryClientProvider>\n\n\n\n```\n\n```\n\n// app/providers.tsx\n\n'use client'\n\nimport {\n\nisServer,\n\nQueryClient,\n\nQueryClientProvider,\n\n} from '@tanstack/react-query'\n\nimport * as React from 'react'\n\nimport { ReactQueryStreamedHydration } from '@tanstack/react-query-next-experimental'\n\nfunction makeQueryClient() {\n\nreturn new QueryClient({\n\ndefaultOptions: {\n\nqueries: {\n\n// With SSR, we usually want to set some default staleTime\n\n// above 0 to avoid refetching immediately on the client\n\nstaleTime: 60 * 1000,\n\n},\n\n},\n\n})\n\n\n\nlet browserQueryClient: QueryClient | undefined = undefined\n\nfunction getQueryClient() {\n\nif (isServer) {\n\n// Server: always make a new query client\n\nreturn makeQueryClient()\n\n} else {\n\n// Browser: make a new query client if we don't already have one\n\n// This is very important, so we don't re-make a new client if React\n\n// suspends during the initial render. This may not be needed if we\n\n// have a suspense boundary BELOW the creation of the query client\n\nif (!browserQueryClient) browserQueryClient = makeQueryClient()\n\nreturn browserQueryClient\n\n\n\nexport function Providers(props: { children: React.ReactNode }) {\n\n// NOTE: Avoid useState when initializing the query client if you don't\n\n// have a suspense boundary between this and the code that may\n\n// suspend because React will throw away the client on the initial\n\n// render if it suspends and there is no boundary\n\nconst queryClient = getQueryClient()\n\nreturn (\n\n<QueryClientProvider client={queryClient}>\n\n<ReactQueryStreamedHydration>\n\n{props.children}\n\n</ReactQueryStreamedHydration>\n\n</QueryClientProvider>\n\n\n\n```\n\nFor more information, check out the NextJs Suspense Streaming Example.\n\nThe big upside is that you no longer need to prefetch queries manually to have SSR work, and it even still streams in the result! This gives you phenomenal DX and lower code complexity.\n\nThe downside is easiest to explain if we look back at the complex request waterfall example in the Performance & Request Waterfalls guide. Server Components with prefetching effectively eliminates the request waterfalls both for the initial page load\n\n**and** any subsequent navigation. This prefetch-less approach however will only flatten the waterfalls on the initial page load but ends up the same deep waterfall as the original example on page navigations:\n\n```\n\n1. |> JS for <Feed>\n\n2. |> getFeed()\n\n3. |> JS for <GraphFeedItem>\n\n4. |> getGraphDataById()\n\n```\n\n```\n\n1. |> JS for <Feed>\n\n2. |> getFeed()\n\n3. |> JS for <GraphFeedItem>\n\n4. |> getGraphDataById()\n\n```\n\nThis is even worse than with getServerSideProps/getStaticProps, since with those we could at least parallelize data- and code-fetching.\n\nIf you value DX/iteration/shipping speed with low code complexity over performance, don't have deeply nested queries, or are on top of your request waterfalls with parallel fetching using tools like useSuspenseQueries, this can be a good tradeoff.\n\nIt might be possible to combine the two approaches, but even we haven't tried that out yet. If you do try this, please report back your findings, or even update these docs with some tips!\n\nServer Components and streaming are still fairly new concepts and we are still figuring out how React Query fits in and what improvements we can make to the API. We welcome suggestions, feedback and bug reports!\n\nSimilarly, it would be impossible to teach all the intricacies of this new paradigm all in one guide, on the first try. If you are missing some piece of information here or have suggestions on how to improve this content, also get in touch, or even better, click the \"Edit on GitHub\" button below and help us out.\n\nTo understand if your application can benefit from React Query when also using Server Components, see the article You Might Not Need React Query.\n\n",
          "title": "Advanced Server Rendering | TanStack Query React Docs",
          "url": "https://tanstack.com/query/latest/docs/framework/react/guides/advanced-ssr"
        }
      ],
      "type": "fetch_url_results"
    },
    {
      "content": [
        {
          "text": "Now I have a comprehensive understanding of the current state of Next.js 16, Supabase SSR, and TanStack Query v5. Let me produce the complete specification document.\n\n---\n\n# Phase 4: API & Data Flow Architecture \u2014 Hyrox AI Coach\n\n## Complete Specification Document\n\n---\n\n## Table of Contents\n\n- **Deliverable 1**: API Specification Document\n- **Deliverable 2**: State Management Plan\n- **Deliverable 3**: Auth & Middleware Spec\n- **Deliverable 4**: Error Handling Playbook\n\n---\n\n# Deliverable 1: API Specification Document\n\n## 1.0 Conventions & Shared Types\n\n### Base URL\nAll API routes are relative to the application root: `/api/...`\n\n### Authentication Pattern\nAll authenticated endpoints extract the user from the Supabase JWT passed via the `Authorization: Bearer <token>` header or the `sb-*` session cookies. Route Handlers use `@supabase/ssr`'s `createServerClient` to get a validated session.\n\n### Shared Response Envelope\n\n```typescript\n// Success responses return data directly (no envelope wrapper)\n// Error responses use a consistent shape:\ntype ApiError = {\n  error: {\n    code: string           // Machine-readable: \"PROFILE_NOT_FOUND\", \"VALIDATION_ERROR\"\n    message: string        // Human-readable message\n    details?: unknown      // Optional structured details (validation errors, etc.)\n  }\n}\n\n// Pagination\ntype PaginatedResponse<T> = {\n  data: T[]\n  pagination: {\n    page: number\n    per_page: number\n    total: number\n    total_pages: number\n    has_next: boolean\n  }\n}\n\n// Common HTTP status codes used:\n// 200 - Success\n// 201 - Created\n// 204 - No Content (successful delete)\n// 400 - Validation error\n// 401 - Not authenticated\n// 403 - Forbidden (RLS violation)\n// 404 - Not found\n// 409 - Conflict (duplicate)\n// 429 - Rate limited\n// 500 - Server error\n// 503 - Upstream service unavailable\n```\n\n### Shared Domain Types\n\n```typescript\n// \u2500\u2500\u2500 Enums \u2500\u2500\u2500\ntype Gender = 'male' | 'female' | 'non_binary' | 'prefer_not_to_say'\ntype FitnessLevel = 'beginner' | 'intermediate' | 'advanced' | 'elite'\ntype HyroxDivision = 'men_open' | 'women_open' | 'men_pro' | 'women_pro' \n  | 'men_doubles' | 'women_doubles' | 'mixed_doubles'\ntype WorkoutType = 'run' | 'strength' | 'hyrox_sim' | 'cross_training' \n  | 'recovery' | 'mobility' | 'race'\ntype RPE = 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10\ntype GoalStatus = 'active' | 'completed' | 'abandoned'\ntype GoalType = 'race_time' | 'station_time' | 'benchmark' | 'consistency' | 'custom'\ntype BenchmarkType = 'ski_erg_1000m' | 'row_1000m' | 'sled_push' | 'sled_pull' \n  | 'burpee_broad_jump' | 'farmers_carry' | 'lunges' | 'wall_balls' \n  | '1k_run' | '5k_run' | '10k_run' | 'deadlift_1rm' | 'back_squat_1rm' | 'custom'\ntype PlanStatus = 'active' | 'completed' | 'archived'\ntype FeedbackType = 'thumbs_up' | 'thumbs_down'\n\n// \u2500\u2500\u2500 Timestamps \u2500\u2500\u2500\n// All timestamps are ISO 8601 strings: \"2026-02-16T12:00:00.000Z\"\n```\n\n---\n\n## Group 1: Authentication\n\n### Design Decision\nAuthentication is handled **entirely client-side** via the Supabase Auth SDK (`@supabase/supabase-js`). There are no custom API routes for auth. The only server-side auth concern is:\n\n1. **`proxy.ts`** \u2014 Refreshes JWT tokens on every request via `supabase.auth.getClaims()`\n2. **`/auth/callback` Route Handler** \u2014 Exchanges OAuth/magic-link codes for sessions\n3. **Database trigger** \u2014 Auto-creates a `profiles` row on `auth.users` INSERT\n\n### 1.1 Auth Callback Route\n\n```\nGET /auth/callback\n```\n\n**Purpose**: Handles OAuth redirect and email confirmation code exchange.\n\n| Field | Value |\n|-------|-------|\n| Auth | Public |\n| Params | `code` (query string) \u2014 the auth code from Supabase |\n| Response | 302 redirect to `/dashboard` (success) or `/auth/error` (failure) |\n\n**Server-side logic**:\n1. Extract `code` from `searchParams`\n2. Call `supabase.auth.exchangeCodeForSession(code)`\n3. Redirect to `/dashboard` on success, `/auth/error?message=...` on failure\n\n### 1.2 Auth Flows (Client-Side \u2014 Document for Reference)\n\n| Flow | SDK Method | Notes |\n|------|-----------|-------|\n| Sign up (email/pw) | `supabase.auth.signUp({ email, password })` | Sends confirmation email. `emailRedirectTo` \u2192 `/auth/callback` |\n| Sign in (email/pw) | `supabase.auth.signInWithPassword({ email, password })` | Returns session immediately |\n| Sign in (OAuth) | `supabase.auth.signInWithOAuth({ provider: 'google' })` | Redirects to provider \u2192 `/auth/callback` |\n| Sign out | `supabase.auth.signOut()` | Clears session cookies |\n| Password reset | `supabase.auth.resetPasswordForEmail(email)` | Sends reset email |\n| Update password | `supabase.auth.updateUser({ password })` | After reset flow |\n| Get session | `supabase.auth.getClaims()` | Server: validates JWT. **Never use `getSession()` server-side.** |\n\n### 1.3 First-Login Hook (Database Trigger)\n\nA Postgres trigger on `auth.users` INSERT creates the initial profile row:\n\n```sql\n-- Trigger function: handle_new_user()\n-- Creates a row in public.profiles with:\n--   id = auth.users.id\n--   email = auth.users.email\n--   display_name = extracted from email (before @)\n--   onboarding_completed = false\n--   created_at = now()\n```\n\nThis ensures a `profiles` row always exists when a user first authenticates. The onboarding flow then updates this row with athlete data.\n\n---\n\n## Group 2: Athlete Profile\n\n### Design Decision: API Routes vs. Direct Supabase Client\n\n**Recommendation: Use API Route Handlers**, not direct Supabase client calls. Reasons:\n\n| Consideration | API Route | Direct Client SDK |\n|--------------|-----------|-------------------|\n| **Validation** | Server-side Zod validation before DB write | Client-side only; RLS can't validate business rules |\n| **Derived fields** | Calculate `race_countdown` server-side | Must duplicate logic client-side |\n| **Side effects** | Cascade updates (e.g., recalculate plan on profile change) | Need separate calls |\n| **Security** | Validate/sanitize input server-side | Rely entirely on RLS |\n| **Complexity** | One more network hop | Slightly faster |\n\n**Verdict**: API routes for mutations (POST/PUT/DELETE). For reads, use direct Supabase client in Server Components with RLS as primary protection, falling back to API route if derived fields are needed. The `GET /api/profile` endpoint exists for client components that need profile data.\n\n### 2.1 GET /api/profile\n\n```\nGET /api/profile\n```\n\n**Purpose**: Get the authenticated user's full profile.\n\n| Field | Value |\n|-------|-------|\n| Auth | Authenticated |\n| Reads | `profiles` |\n| Rate limit | 60/min |\n\n**Response 200**:\n```typescript\ntype ProfileResponse = {\n  id: string                          // UUID (matches auth.users.id)\n  email: string\n  display_name: string\n  avatar_url: string | null\n  \n  // Athlete data\n  age: number | null\n  gender: Gender | null\n  height_cm: number | null\n  weight_kg: number | null\n  fitness_level: FitnessLevel | null\n  hyrox_division: HyroxDivision | null\n  hyrox_experience: number | null     // Number of Hyrox races completed\n  \n  // Training context\n  weekly_run_km: number | null\n  strength_days_per_week: number | null\n  training_hours_per_week: number | null\n  \n  // Race info\n  race_date: string | null            // ISO date \"2026-06-08\"\n  race_location: string | null\n  goal_time_minutes: number | null\n  race_countdown_days: number | null  // Derived: calculated from race_date\n  \n  // Weaknesses & notes\n  weaknesses: string[] | null         // e.g. [\"sled_push\", \"wall_balls\"]\n  injuries: string | null             // Free text\n  notes: string | null\n  \n  // Meta\n  onboarding_completed: boolean\n  created_at: string\n  updated_at: string\n}\n```\n\n**Error Responses**:\n- `401` \u2014 Not authenticated\n- `404` \u2014 Profile not found (should never happen due to trigger, but guard)\n\n### 2.2 POST /api/profile\n\n```\nPOST /api/profile\n```\n\n**Purpose**: Complete initial profile setup (onboarding). Updates the auto-created profile row.\n\n| Field | Value |\n|-------|-------|\n| Auth | Authenticated |\n| Writes | `profiles` |\n| Rate limit | 10/min |\n\n**Request Body**:\n```typescript\ntype CreateProfileRequest = {\n  display_name?: string\n  age?: number                        // 13-100\n  gender?: Gender\n  height_cm?: number                  // 100-250\n  weight_kg?: number                  // 30-300\n  fitness_level?: FitnessLevel\n  hyrox_division?: HyroxDivision\n  hyrox_experience?: number           // 0-100\n  weekly_run_km?: number              // 0-300\n  strength_days_per_week?: number     // 0-7\n  training_hours_per_week?: number    // 0-40\n  race_date?: string                  // ISO date, must be in the future\n  race_location?: string\n  goal_time_minutes?: number          // 30-240\n  weaknesses?: string[]\n  injuries?: string\n  notes?: string\n}\n```\n\n**Server-side logic**:\n1. Validate with Zod schema\n2. If `race_date` provided, validate it's in the future\n3. Set `onboarding_completed = true`\n4. Update profile row (upsert on `user_id`)\n5. Return complete profile\n\n**Response 200**: `ProfileResponse`\n\n**Error Responses**:\n- `400` \u2014 Validation error (with field-level details)\n- `401` \u2014 Not authenticated\n- `409` \u2014 Profile already completed (idempotent \u2014 re-run is fine, but flag it)\n\n### 2.3 PUT /api/profile\n\n```\nPUT /api/profile\n```\n\n**Purpose**: Update profile fields. Partial update (PATCH semantics).\n\n| Field | Value |\n|-------|-------|\n| Auth | Authenticated |\n| Writes | `profiles` |\n| Rate limit | 30/min |\n\n**Request Body**: Same as `CreateProfileRequest` \u2014 all fields optional. Only provided fields are updated.\n\n**Server-side logic**:\n1. Validate with Zod schema (partial)\n2. If `race_date` updated, recalculate `race_countdown_days`\n3. Update `updated_at`\n4. Return complete profile\n\n**Response 200**: `ProfileResponse`\n\n**Error Responses**:\n- `400` \u2014 Validation error\n- `401` \u2014 Not authenticated\n\n### 2.4 DELETE /api/profile\n\n```\nDELETE /api/profile\n```\n\n**Purpose**: Delete the user's account and all associated data.\n\n| Field | Value |\n|-------|-------|\n| Auth | Authenticated |\n| Writes | All user tables (cascade) |\n| Rate limit | 1/hour |\n\n**Server-side logic**:\n1. Uses `SUPABASE_SERVICE_ROLE_KEY` to call `supabase.auth.admin.deleteUser(userId)`\n2. All user data cascades via `ON DELETE CASCADE` foreign keys\n3. Return 204\n\n**Response 204**: No content\n\n**Error Responses**:\n- `401` \u2014 Not authenticated\n- `500` \u2014 Deletion failed\n\n---\n\n## Group 3: AI Coaching Chat\n\n### 3.1 POST /api/chat\n\n```\nPOST /api/chat\n```\n\n**Purpose**: The core product \u2014 send a message and receive a streaming AI coaching response. Implements the full 9-step coaching pipeline.\n\n| Field | Value |\n|-------|-------|\n| Auth | Authenticated |\n| Reads | `profiles`, `conversations`, `messages`, `hyrox_knowledge_chunks` (via RPC) |\n| Writes | `messages`, `conversations` (updated_at) |\n| Rate limit | 20/min per user |\n| Response type | `text/event-stream` (SSE) |\n\n**Request Body**:\n```typescript\ntype ChatRequest = {\n  conversation_id: string    // UUID \u2014 must belong to user\n  message: string            // 1-5000 characters\n}\n```\n\n**Server-side logic** (THE CRITICAL PATH \u2014 implements steps 1-9):\n\n```\nStep 1: Validate request, verify conversation ownership\nStep 2: Embed user message via OpenAI text-embedding-3-small\nStep 3: Hybrid search via supabase.rpc(\"hybrid_search_chunks\", {\n          query_text: message,\n          query_embedding: embedding,\n          match_count: 5,\n          full_text_weight: 1.0,\n          semantic_weight: 1.0,\n          rrf_k: 50\n        })\nStep 4: Format chunks \u2192 context string\nStep 5: Build system prompt via SYSTEM_PROMPT_TEMPLATE.replace(\"{context}\", context)\nStep 6: Load athlete profile, calculate race_countdown\nStep 7: Load last 5-8 conversation turns from messages table\nStep 8: Assemble messages array:\n         [system_prompt, ?athlete_profile_system_msg, ...history, user_message]\nStep 9: Call Nebius streaming API:\n         POST https://api.tokenfactory.nebius.com/v1/chat/completions\n         {\n           model: NEBIUS_MODEL,\n           messages: assembled,\n           temperature: 0.7,\n           max_tokens: 1200,\n           stream: true,\n           stream_options: { include_usage: true }\n         }\nStep 10: Stream to client via SSE\nStep 11: After stream completes, save both messages to DB\n```\n\n**SSE Stream Format**:\n```\ndata: {\"token\": \"Hey\"}\\n\\n\ndata: {\"token\": \" there\"}\\n\\n\ndata: {\"token\": \",\"}\\n\\n\ndata: {\"token\": \" let\"}\\n\\n\n...\ndata: {\"token\": \"\", \"usage\": {\"prompt_tokens\": 847, \"completion_tokens\": 312}}\\n\\n\ndata: [DONE]\\n\\n\n```\n\n**Response Headers**:\n```\nContent-Type: text/event-stream\nCache-Control: no-cache, no-transform\nConnection: keep-alive\nX-Accel-Buffering: no\n```\n\n**Error SSE Events** (sent as SSE, not HTTP error codes, since stream has started):\n```\ndata: {\"error\": {\"code\": \"EMBEDDING_FAILED\", \"message\": \"Proceeding without context\"}}\\n\\n\ndata: {\"error\": {\"code\": \"MODEL_UNAVAILABLE\", \"message\": \"Coach K is temporarily unavailable\"}}\\n\\n\ndata: [DONE]\\n\\n\n```\n\n**Pre-stream HTTP Error Responses**:\n- `400` \u2014 Invalid request (empty message, invalid conversation_id)\n- `401` \u2014 Not authenticated\n- `403` \u2014 Conversation doesn't belong to user\n- `404` \u2014 Conversation not found\n- `429` \u2014 Rate limited\n\n**Post-stream DB Write** (fire-and-forget, don't block the user):\n```typescript\ntype MessageRecord = {\n  id: string                // UUID\n  conversation_id: string\n  role: 'user' | 'assistant'\n  content: string\n  rag_chunks_used: string[] | null   // chunk IDs used for this response\n  tokens_in: number | null\n  tokens_out: number | null\n  latency_ms: number | null          // Time from request to last token\n  model: string | null               // NEBIUS_MODEL value\n  feedback: FeedbackType | null\n  created_at: string\n}\n```\n\n### 3.2 POST /api/conversations\n\n```\nPOST /api/conversations\n```\n\n| Field | Value |\n|-------|-------|\n| Auth | Authenticated |\n| Writes | `conversations` |\n| Rate limit | 30/min |\n\n**Request Body**:\n```typescript\ntype CreateConversationRequest = {\n  title?: string    // Optional \u2014 auto-generated from first message if omitted\n}\n```\n\n**Response 201**:\n```typescript\ntype ConversationResponse = {\n  id: string\n  user_id: string\n  title: string              // Default: \"New conversation\"\n  is_pinned: boolean         // Default: false\n  message_count: number      // Default: 0\n  created_at: string\n  updated_at: string\n}\n```\n\n### 3.3 GET /api/conversations\n\n```\nGET /api/conversations?page=1&per_page=20\n```\n\n| Field | Value |\n|-------|-------|\n| Auth | Authenticated |\n| Reads | `conversations` |\n| Rate limit | 60/min |\n\n**Query Parameters**:\n```typescript\n{\n  page?: number         // Default: 1\n  per_page?: number     // Default: 20, max: 50\n}\n```\n\n**Response 200**: `PaginatedResponse<ConversationResponse>`\n\n**Ordering**: Pinned first, then by `updated_at` DESC.\n\n### 3.4 GET /api/conversations/:id/messages\n\n```\nGET /api/conversations/:id/messages?page=1&per_page=50\n```\n\n| Field | Value |\n|-------|-------|\n| Auth | Authenticated |\n| Reads | `messages` |\n| Rate limit | 60/min |\n\n**Query Parameters**:\n```typescript\n{\n  page?: number        // Default: 1\n  per_page?: number    // Default: 50, max: 100\n}\n```\n\n**Response 200**:\n```typescript\ntype MessageResponse = {\n  id: string\n  role: 'user' | 'assistant'\n  content: string\n  feedback: FeedbackType | null\n  created_at: string\n}\n// Wrapped in PaginatedResponse<MessageResponse>\n```\n\n**Ordering**: `created_at` ASC (oldest first \u2014 natural chat order). Pagination loads from most recent backward (page 1 = newest messages).\n\n### 3.5 PUT /api/conversations/:id\n\n```\nPUT /api/conversations/:id\n```\n\n| Field | Value |\n|-------|-------|\n| Auth | Authenticated |\n| Writes | `conversations` |\n| Rate limit | 30/min |\n\n**Request Body**:\n```typescript\ntype UpdateConversationRequest = {\n  title?: string\n  is_pinned?: boolean\n}\n```\n\n**Response 200**: `ConversationResponse`\n\n### 3.6 DELETE /api/conversations/:id\n\n```\nDELETE /api/conversations/:id\n```\n\n| Field | Value |\n|-------|-------|\n| Auth | Authenticated |\n| Writes | `conversations`, `messages` (cascade) |\n| Rate limit | 10/min |\n\n**Response 204**: No content\n\n### 3.7 POST /api/messages/:id/feedback\n\n```\nPOST /api/messages/:id/feedback\n```\n\n| Field | Value |\n|-------|-------|\n| Auth | Authenticated |\n| Writes | `messages` |\n| Rate limit | 60/min |\n\n**Request Body**:\n```typescript\ntype FeedbackRequest = {\n  feedback: FeedbackType   // 'thumbs_up' | 'thumbs_down'\n}\n```\n\n**Server-side logic**:\n1. Verify message belongs to user's conversation\n2. Update `messages.feedback` field\n3. Toggle behavior: if same feedback value sent again, clear it (set to null)\n\n**Response 200**:\n```typescript\n{ feedback: FeedbackType | null }\n```\n\n---\n\n## Group 4: Workout Logging\n\n### 4.1 POST /api/workouts\n\n```\nPOST /api/workouts\n```\n\n| Field | Value |\n|-------|-------|\n| Auth | Authenticated |\n| Writes | `workouts`, potentially `personal_records` |\n| Rate limit | 30/min |\n\n**Request Body**:\n```typescript\ntype CreateWorkoutRequest = {\n  workout_type: WorkoutType\n  title: string                          // 1-200 chars\n  date: string                           // ISO date \"2026-02-16\"\n  duration_minutes: number               // 1-600\n  rpe: RPE | null\n  notes: string | null                   // Max 2000 chars\n  \n  // Structured data (optional, based on workout_type)\n  distance_km: number | null\n  calories: number | null\n  heart_rate_avg: number | null\n  heart_rate_max: number | null\n  \n  // Exercise details\n  exercises: WorkoutExercise[] | null\n  \n  // Link to training plan day (if completing a planned workout)\n  training_plan_day_id: string | null\n}\n\ntype WorkoutExercise = {\n  exercise_id: string | null          // Reference to exercises table, or null for custom\n  exercise_name: string               // Display name\n  sets: ExerciseSet[]\n  notes: string | null\n}\n\ntype ExerciseSet = {\n  set_number: number\n  reps: number | null\n  weight_kg: number | null\n  distance_m: number | null\n  duration_seconds: number | null\n  completed: boolean\n}\n```\n\n**Server-side logic**:\n1. Validate with Zod\n2. Insert workout\n3. **Check for new PRs**: Compare relevant metrics against `personal_records` table\n4. If new PR detected: insert/update `personal_records` row, return `new_prs` in response\n5. If `training_plan_day_id` provided: mark that day as completed\n\n**Response 201**:\n```typescript\ntype WorkoutResponse = {\n  id: string\n  user_id: string\n  workout_type: WorkoutType\n  title: string\n  date: string\n  duration_minutes: number\n  rpe: RPE | null\n  notes: string | null\n  distance_km: number | null\n  calories: number | null\n  heart_rate_avg: number | null\n  heart_rate_max: number | null\n  exercises: WorkoutExercise[] | null\n  training_plan_day_id: string | null\n  is_deleted: boolean\n  created_at: string\n  updated_at: string\n  \n  // Included on create only\n  new_prs?: PersonalRecordResponse[]\n}\n```\n\n### 4.2 GET /api/workouts\n\n```\nGET /api/workouts?page=1&per_page=20&from=2026-01-01&to=2026-02-16&type=run\n```\n\n| Field | Value |\n|-------|-------|\n| Auth | Authenticated |\n| Reads | `workouts` |\n| Rate limit | 60/min |\n\n**Query Parameters**:\n```typescript\n{\n  page?: number\n  per_page?: number       // Default: 20, max: 50\n  from?: string           // ISO date \u2014 inclusive\n  to?: string             // ISO date \u2014 inclusive\n  type?: WorkoutType      // Filter by workout type\n}\n```\n\n**Response 200**: `PaginatedResponse<WorkoutResponse>` (without `exercises` for list \u2014 lightweight)\n\n**Ordering**: `date` DESC, `created_at` DESC\n\n**Note**: Soft-deleted workouts (`is_deleted = true`) are excluded.\n\n### 4.3 GET /api/workouts/:id\n\n```\nGET /api/workouts/:id\n```\n\n| Field | Value |\n|-------|-------|\n| Auth | Authenticated |\n| Reads | `workouts` |\n| Rate limit | 60/min |\n\n**Response 200**: Full `WorkoutResponse` including `exercises` array.\n\n### 4.4 PUT /api/workouts/:id\n\n```\nPUT /api/workouts/:id\n```\n\n| Field | Value |\n|-------|-------|\n| Auth | Authenticated |\n| Writes | `workouts`, potentially `personal_records` |\n| Rate limit | 30/min |\n\n**Request Body**: Same as `CreateWorkoutRequest`, all fields optional.\n\n**Server-side logic**:\n1. Validate\n2. Update workout\n3. Re-check PRs (may need to recalculate if metrics changed)\n\n**Response 200**: `WorkoutResponse`\n\n### 4.5 DELETE /api/workouts/:id\n\n```\nDELETE /api/workouts/:id\n```\n\n| Field | Value |\n|-------|-------|\n| Auth | Authenticated |\n| Writes | `workouts` |\n| Rate limit | 10/min |\n\n**Server-side logic**: Soft-delete \u2014 sets `is_deleted = true`, `deleted_at = now()`. Does NOT recalculate PRs (preserves history).\n\n**Response 204**: No content\n\n---\n\n## Group 5: Training Plans\n\n### 5.1 POST /api/training-plans\n\n```\nPOST /api/training-plans\n```\n\n| Field | Value |\n|-------|-------|\n| Auth | Authenticated |\n| Writes | `training_plans`, `training_plan_weeks`, `training_plan_days` |\n| Rate limit | 10/min |\n\n**Request Body**:\n```typescript\ntype CreateTrainingPlanRequest = {\n  title: string                    // 1-200 chars\n  description: string | null\n  start_date: string               // ISO date\n  end_date: string                 // ISO date\n  source: 'manual' | 'ai_generated'\n  weeks: TrainingPlanWeekInput[]\n}\n\ntype TrainingPlanWeekInput = {\n  week_number: number              // 1-52\n  theme: string | null             // e.g. \"Base Building\", \"Peak Week\"\n  days: TrainingPlanDayInput[]\n}\n\ntype TrainingPlanDayInput = {\n  day_of_week: number              // 0=Sunday, 6=Saturday\n  date: string                     // ISO date\n  workout_type: WorkoutType\n  title: string\n  description: string | null\n  duration_minutes: number | null\n  exercises: PlannedExercise[] | null\n  is_rest_day: boolean\n}\n\ntype PlannedExercise = {\n  exercise_name: string\n  sets: number\n  reps: string                     // \"8-10\" or \"5\"\n  weight_prescription: string | null  // \"70% 1RM\" or \"bodyweight\"\n  rest_seconds: number | null\n  notes: string | null\n}\n```\n\n**Server-side logic**:\n1. Validate all dates (end_date > start_date, dates within range)\n2. If user has another `active` plan: prompt confirmation or auto-archive\n3. Insert plan + weeks + days in a transaction\n4. Set status to `active`\n\n**Response 201**:\n```typescript\ntype TrainingPlanResponse = {\n  id: string\n  user_id: string\n  title: string\n  description: string | null\n  start_date: string\n  end_date: string\n  status: PlanStatus\n  source: 'manual' | 'ai_generated'\n  progress_percent: number           // Derived: completed_days / total_days * 100\n  total_days: number\n  completed_days: number\n  created_at: string\n  updated_at: string\n}\n\n// Full plan response includes weeks:\ntype TrainingPlanDetailResponse = TrainingPlanResponse & {\n  weeks: TrainingPlanWeekResponse[]\n}\n\ntype TrainingPlanWeekResponse = {\n  id: string\n  week_number: number\n  theme: string | null\n  days: TrainingPlanDayResponse[]\n}\n\ntype TrainingPlanDayResponse = {\n  id: string\n  day_of_week: number\n  date: string\n  workout_type: WorkoutType\n  title: string\n  description: string | null\n  duration_minutes: number | null\n  exercises: PlannedExercise[] | null\n  is_rest_day: boolean\n  is_completed: boolean\n  completed_at: string | null\n  workout_id: string | null         // Link to actual workout log if completed\n}\n```\n\n### 5.2 GET /api/training-plans\n\n```\nGET /api/training-plans?status=active\n```\n\n| Field | Value |\n|-------|-------|\n| Auth | Authenticated |\n| Reads | `training_plans` |\n| Rate limit | 60/min |\n\n**Query Parameters**:\n```typescript\n{\n  status?: PlanStatus    // Filter by status\n}\n```\n\n**Response 200**: `TrainingPlanResponse[]` (without weeks \u2014 list view)\n\n### 5.3 GET /api/training-plans/:id\n\n```\nGET /api/training-plans/:id\n```\n\n| Field | Value |\n|-------|-------|\n| Auth | Authenticated |\n| Reads | `training_plans`, `training_plan_weeks`, `training_plan_days` |\n| Rate limit | 60/min |\n\n**Response 200**: `TrainingPlanDetailResponse` (full plan with all weeks and days)\n\n### 5.4 PUT /api/training-plans/:id\n\n```\nPUT /api/training-plans/:id\n```\n\n| Field | Value |\n|-------|-------|\n| Auth | Authenticated |\n| Writes | `training_plans` |\n| Rate limit | 30/min |\n\n**Request Body**:\n```typescript\ntype UpdateTrainingPlanRequest = {\n  title?: string\n  description?: string\n  status?: PlanStatus\n}\n```\n\n**Response 200**: `TrainingPlanResponse`\n\n### 5.5 DELETE /api/training-plans/:id\n\n```\nDELETE /api/training-plans/:id\n```\n\n| Field | Value |\n|-------|-------|\n| Auth | Authenticated |\n| Writes | `training_plans` |\n| Rate limit | 10/min |\n\n**Server-side logic**: Sets `status = 'archived'` (soft delete \u2014 training data is never destroyed).\n\n**Response 204**: No content\n\n### 5.6 PUT /api/training-plans/:id/days/:dayId\n\n```\nPUT /api/training-plans/:id/days/:dayId\n```\n\n| Field | Value |\n|-------|-------|\n| Auth | Authenticated |\n| Writes | `training_plan_days` |\n| Rate limit | 30/min |\n\n**Request Body**:\n```typescript\ntype UpdatePlanDayRequest = {\n  workout_type?: WorkoutType\n  title?: string\n  description?: string\n  duration_minutes?: number\n  exercises?: PlannedExercise[]\n  is_rest_day?: boolean\n}\n```\n\n**Response 200**: `TrainingPlanDayResponse`\n\n### 5.7 POST /api/training-plans/:id/days/:dayId/complete\n\n```\nPOST /api/training-plans/:id/days/:dayId/complete\n```\n\n| Field | Value |\n|-------|-------|\n| Auth | Authenticated |\n| Writes | `training_plan_days`, `workouts`, potentially `personal_records` |\n| Rate limit | 30/min |\n\n**Request Body**:\n```typescript\ntype CompletePlanDayRequest = {\n  // Full workout data \u2014 same as CreateWorkoutRequest minus training_plan_day_id\n  duration_minutes: number\n  rpe: RPE | null\n  notes: string | null\n  distance_km: number | null\n  exercises: WorkoutExercise[] | null\n}\n```\n\n**Server-side logic**:\n1. Create a workout log with `training_plan_day_id` set\n2. Mark day as `is_completed = true`, `completed_at = now()`\n3. Link `workout_id` on the plan day\n4. Check for PRs\n5. Recalculate plan `progress_percent`\n\n**Response 201**: `WorkoutResponse` (with `new_prs` if any)\n\n---\n\n## Group 6: Benchmarks & PRs\n\n### 6.1 POST /api/benchmarks\n\n```\nPOST /api/benchmarks\n```\n\n| Field | Value |\n|-------|-------|\n| Auth | Authenticated |\n| Writes | `benchmarks`, `personal_records` |\n| Rate limit | 30/min |\n\n**Request Body**:\n```typescript\ntype CreateBenchmarkRequest = {\n  benchmark_type: BenchmarkType\n  value: number                     // Time in seconds, weight in kg, etc.\n  unit: 'seconds' | 'kg' | 'meters' | 'reps'\n  date: string                      // ISO date\n  notes: string | null\n}\n```\n\n**Server-side logic**:\n1. Insert benchmark record\n2. Compare against existing PR for this benchmark type\n3. If new PR: update `personal_records` table\n4. Return benchmark with PR status\n\n**Response 201**:\n```typescript\ntype BenchmarkResponse = {\n  id: string\n  benchmark_type: BenchmarkType\n  value: number\n  unit: string\n  date: string\n  notes: string | null\n  is_pr: boolean                    // Was this a new PR?\n  created_at: string\n}\n```\n\n### 6.2 GET /api/benchmarks\n\n```\nGET /api/benchmarks?type=ski_erg_1000m&page=1&per_page=20\n```\n\n| Field | Value |\n|-------|-------|\n| Auth | Authenticated |\n| Reads | `benchmarks` |\n| Rate limit | 60/min |\n\n**Query Parameters**:\n```typescript\n{\n  type?: BenchmarkType\n  page?: number\n  per_page?: number    // Default: 20\n}\n```\n\n**Response 200**: `PaginatedResponse<BenchmarkResponse>`\n\n### 6.3 GET /api/personal-records\n\n```\nGET /api/personal-records\n```\n\n| Field | Value |\n|-------|-------|\n| Auth | Authenticated |\n| Reads | `personal_records` |\n| Rate limit | 60/min |\n\n**Response 200**:\n```typescript\ntype PersonalRecordResponse = {\n  id: string\n  benchmark_type: BenchmarkType\n  value: number\n  unit: string\n  achieved_at: string               // ISO date\n  previous_value: number | null     // What the old PR was\n  improvement_percent: number | null\n}\n\n// Returns: PersonalRecordResponse[]\n```\n\n### 6.4 GET /api/personal-records/history\n\n```\nGET /api/personal-records/history?type=ski_erg_1000m\n```\n\n| Field | Value |\n|-------|-------|\n| Auth | Authenticated |\n| Reads | `benchmarks` |\n| Rate limit | 60/min |\n\n**Query Parameters**:\n```typescript\n{\n  type: BenchmarkType   // Required\n}\n```\n\n**Response 200**:\n```typescript\ntype PRHistoryPoint = {\n  date: string\n  value: number\n  was_pr: boolean       // Was this value a PR at the time?\n}\n\n// Returns: PRHistoryPoint[]\n```\n\n**Ordering**: `date` ASC (for chart rendering)\n\n---\n\n## Group 7: Race Results\n\n### 7.1 POST /api/races\n\n```\nPOST /api/races\n```\n\n| Field | Value |\n|-------|-------|\n| Auth | Authenticated |\n| Writes | `race_results`, `race_splits` |\n| Rate limit | 10/min |\n\n**Request Body**:\n```typescript\ntype CreateRaceRequest = {\n  race_name: string                  // \"Hyrox London 2026\"\n  race_date: string                  // ISO date\n  location: string | null\n  division: HyroxDivision\n  overall_time_seconds: number       // Total time in seconds\n  overall_rank: number | null\n  division_rank: number | null\n  notes: string | null\n  \n  splits: RaceSplitInput[]\n}\n\ntype RaceSplitInput = {\n  station_order: number             // 1-8\n  station_name: string              // \"Ski Erg\", \"Sled Push\", etc.\n  station_time_seconds: number\n  run_time_seconds: number          // The 1km run before this station\n  transition_time_seconds: number | null\n}\n```\n\n**Response 201**:\n```typescript\ntype RaceResultResponse = {\n  id: string\n  race_name: string\n  race_date: string\n  location: string | null\n  division: HyroxDivision\n  overall_time_seconds: number\n  overall_time_formatted: string    // Derived: \"1:12:34\"\n  overall_rank: number | null\n  division_rank: number | null\n  notes: string | null\n  total_run_time_seconds: number    // Derived: sum of all run splits\n  total_station_time_seconds: number // Derived: sum of all station splits\n  created_at: string\n  updated_at: string\n}\n```\n\n### 7.2 GET /api/races\n\n```\nGET /api/races\n```\n\n| Field | Value |\n|-------|-------|\n| Auth | Authenticated |\n| Reads | `race_results` |\n| Rate limit | 60/min |\n\n**Response 200**: `RaceResultResponse[]`\n\n**Ordering**: `race_date` DESC\n\n### 7.3 GET /api/races/:id\n\n```\nGET /api/races/:id\n```\n\n| Field | Value |\n|-------|-------|\n| Auth | Authenticated |\n| Reads | `race_results`, `race_splits` |\n| Rate limit | 60/min |\n\n**Response 200**:\n```typescript\ntype RaceDetailResponse = RaceResultResponse & {\n  splits: RaceSplitResponse[]\n}\n\ntype RaceSplitResponse = {\n  id: string\n  station_order: number\n  station_name: string\n  station_time_seconds: number\n  station_time_formatted: string    // \"3:45\"\n  run_time_seconds: number\n  run_time_formatted: string        // \"4:30\"\n  transition_time_seconds: number | null\n  cumulative_time_seconds: number   // Derived: running total at this point\n}\n```\n\n### 7.4 PUT /api/races/:id\n\n```\nPUT /api/races/:id\n```\n\n| Field | Value |\n|-------|-------|\n| Auth | Authenticated |\n| Writes | `race_results`, `race_splits` |\n| Rate limit | 10/min |\n\n**Request Body**: Same as `CreateRaceRequest`, all fields optional. If `splits` provided, replaces all splits (delete + re-insert).\n\n**Response 200**: `RaceDetailResponse`\n\n### 7.5 DELETE /api/races/:id\n\n```\nDELETE /api/races/:id\n```\n\n| Field | Value |\n|-------|-------|\n| Auth | Authenticated |\n| Writes | `race_results`, `race_splits` (cascade) |\n| Rate limit | 10/min |\n\n**Response 204**: No content\n\n---\n\n## Group 8: Goals & Achievements\n\n### 8.1 POST /api/goals\n\n```\nPOST /api/goals\n```\n\n| Field | Value |\n|-------|-------|\n| Auth | Authenticated |\n| Writes | `goals` |\n| Rate limit | 20/min |\n\n**Request Body**:\n```typescript\ntype CreateGoalRequest = {\n  goal_type: GoalType\n  title: string                     // \"Break 80 minutes\"\n  description: string | null\n  target_value: number              // e.g. 4800 (80 min in seconds)\n  target_unit: string               // \"seconds\", \"kg\", \"count\"\n  current_value: number | null      // Starting value\n  target_date: string | null        // ISO date (optional deadline)\n}\n```\n\n**Response 201**:\n```typescript\ntype GoalResponse = {\n  id: string\n  goal_type: GoalType\n  title: string\n  description: string | null\n  target_value: number\n  target_unit: string\n  current_value: number\n  progress_percent: number          // Derived: current/target * 100 (capped at 100)\n  target_date: string | null\n  status: GoalStatus\n  completed_at: string | null\n  created_at: string\n  updated_at: string\n}\n```\n\n### 8.2 GET /api/goals\n\n```\nGET /api/goals?status=active\n```\n\n| Field | Value |\n|-------|-------|\n| Auth | Authenticated |\n| Reads | `goals` |\n| Rate limit | 60/min |\n\n**Query Parameters**:\n```typescript\n{\n  status?: GoalStatus    // Default: 'active'\n}\n```\n\n**Response 200**: `GoalResponse[]`\n\n### 8.3 PUT /api/goals/:id\n\n```\nPUT /api/goals/:id\n```\n\n| Field | Value |\n|-------|-------|\n| Auth | Authenticated |\n| Writes | `goals`, potentially `user_achievements` |\n| Rate limit | 30/min |\n\n**Request Body**:\n```typescript\ntype UpdateGoalRequest = {\n  title?: string\n  description?: string\n  target_value?: number\n  current_value?: number\n  target_date?: string\n  status?: GoalStatus\n}\n```\n\n**Server-side logic**:\n1. If `current_value >= target_value`: auto-set `status = 'completed'`, `completed_at = now()`\n2. If goal completed: check for achievement unlocks (e.g., \"First Goal Completed\")\n3. Return achievement unlocks in response if any\n\n**Response 200**:\n```typescript\ntype GoalUpdateResponse = GoalResponse & {\n  achievements_unlocked?: AchievementResponse[]\n}\n```\n\n### 8.4 DELETE /api/goals/:id\n\n```\nDELETE /api/goals/:id\n```\n\n| Field | Value |\n|-------|-------|\n| Auth | Authenticated |\n| Writes | `goals` |\n| Rate limit | 10/min |\n\n**Server-side logic**: Sets `status = 'abandoned'` (soft delete).\n\n**Response 204**: No content\n\n### 8.5 GET /api/achievements\n\n```\nGET /api/achievements\n```\n\n| Field | Value |\n|-------|-------|\n| Auth | Authenticated |\n| Reads | `user_achievements`, `achievement_definitions` |\n| Rate limit | 60/min |\n\n**Response 200**:\n```typescript\ntype AchievementResponse = {\n  id: string\n  definition_id: string\n  title: string\n  description: string\n  icon: string                     // Icon name or emoji\n  category: string                 // \"training\", \"racing\", \"consistency\", etc.\n  earned_at: string\n}\n\n// Returns: AchievementResponse[]\n```\n\n### 8.6 GET /api/achievements/available\n\n```\nGET /api/achievements/available\n```\n\n| Field | Value |\n|-------|-------|\n| Auth | Authenticated |\n| Reads | `achievement_definitions`, `user_achievements` |\n| Rate limit | 60/min |\n\n**Response 200**:\n```typescript\ntype AchievementDefinitionResponse = {\n  id: string\n  title: string\n  description: string\n  icon: string\n  category: string\n  criteria: string                 // Human-readable criteria\n  is_earned: boolean\n  earned_at: string | null\n  progress: number | null          // 0-100, null if not trackable\n}\n\n// Returns: AchievementDefinitionResponse[]\n```\n\n---\n\n## Group 9: Dashboard Aggregates\n\n### Design Decision: Single Aggregate vs. Multiple Endpoints\n\n**Recommendation: Single aggregate endpoint** with parallel server-side queries.\n\n| Approach | Pros | Cons |\n|----------|------|------|\n| **Single `/api/dashboard`** | One request, one loading state, easy to cache as unit, reduces client waterfall | Slower if any sub-query is slow, all-or-nothing cache |\n| **Multiple endpoints** | Individual caching, partial updates, parallel from client | Multiple loading states, client waterfall risk, more complex |\n\n**Verdict**: Use a single endpoint. Server-side, run all queries in parallel with `Promise.all()`. The dashboard is the landing page \u2014 it must load fast with a single request. For partial updates after mutations, use TanStack Query's `invalidateQueries` to refetch just this one endpoint (fast server-side re-aggregation).\n\n### 9.1 GET /api/dashboard\n\n```\nGET /api/dashboard\n```\n\n| Field | Value |\n|-------|-------|\n| Auth | Authenticated |\n| Reads | `profiles`, `training_plans`, `training_plan_days`, `workouts`, `personal_records`, `goals`, `benchmarks`, `race_results` |\n| Rate limit | 60/min |\n| Cache | stale-while-revalidate: 30s |\n\n**Response 200**:\n```typescript\ntype DashboardResponse = {\n  // Race countdown\n  race: {\n    race_date: string | null\n    race_location: string | null\n    countdown_days: number | null\n    goal_time_minutes: number | null\n  } | null\n\n  // Today's workout from active training plan\n  today_workout: {\n    plan_id: string\n    plan_title: string\n    day: TrainingPlanDayResponse\n  } | null\n\n  // Weekly training summary (current week: Mon-Sun)\n  weekly_summary: {\n    week_start: string              // ISO date\n    workouts_completed: number\n    total_duration_minutes: number\n    average_rpe: number | null\n    workout_types: Record<WorkoutType, number>  // Count per type\n  }\n\n  // Training streak\n  streak: {\n    current_days: number            // Consecutive days with a logged workout\n    longest_days: number\n    last_workout_date: string | null\n  }\n\n  // Recent PRs (last 30 days)\n  recent_prs: PersonalRecordResponse[]    // Max 5\n\n  // Active goals progress\n  active_goals: GoalResponse[]            // Max 5\n\n  // Estimated race time (based on latest benchmarks)\n  estimated_race_time: {\n    estimated_seconds: number | null\n    confidence: 'low' | 'medium' | 'high'\n    based_on: string[]              // Which benchmarks were used\n    last_calculated: string\n  } | null\n  \n  // Quick stats\n  stats: {\n    total_workouts: number\n    total_races: number\n    member_since: string\n  }\n}\n```\n\n**Server-side logic**: Run 8+ queries in parallel:\n```\nPromise.all([\n  getProfile(userId),\n  getActivePlanTodayWorkout(userId),\n  getWeeklySummary(userId),\n  getStreak(userId),\n  getRecentPRs(userId),\n  getActiveGoals(userId),\n  estimateRaceTime(userId),\n  getQuickStats(userId),\n])\n```\n\n**Race time estimation logic** (simplified):\n- If user has benchmarks for \u22654 stations: weighted sum with known correlations\n- Confidence based on recency and completeness of benchmark data\n- This is a server-side calculation, NOT an AI call\n\n---\n\n## Group 10: Reference Data\n\n### 10.1 GET /api/stations\n\n```\nGET /api/stations\n```\n\n| Field | Value |\n|-------|-------|\n| Auth | Public |\n| Reads | `hyrox_stations` |\n| Cache | `Cache-Control: public, max-age=86400, s-maxage=86400` (24h) |\n\n**Response 200**:\n```typescript\ntype StationResponse = {\n  id: string\n  station_order: number\n  name: string                      // \"Ski Erg\"\n  description: string\n  distance_or_reps: string          // \"1000m\" or \"100m\"\n  equipment: string[]\n  tips: string[]\n  muscles_targeted: string[]\n  preceding_run_km: number          // Always 1.0\n}\n\n// Returns: StationResponse[]\n```\n\n### 10.2 GET /api/exercises\n\n```\nGET /api/exercises?category=strength\n```\n\n| Field | Value |\n|-------|-------|\n| Auth | Public |\n| Reads | `exercises` |\n| Cache | `Cache-Control: public, max-age=86400` |\n\n**Query Parameters**:\n```typescript\n{\n  category?: string     // \"strength\", \"cardio\", \"mobility\", \"hyrox_specific\"\n  search?: string       // Text search on name\n}\n```\n\n**Response 200**:\n```typescript\ntype ExerciseResponse = {\n  id: string\n  name: string\n  category: string\n  description: string\n  muscles_targeted: string[]\n  equipment: string[]\n  video_url: string | null\n}\n\n// Returns: ExerciseResponse[]\n```\n\n### 10.3 GET /api/benchmarks/reference\n\n```\nGET /api/benchmarks/reference\n```\n\n| Field | Value |\n|-------|-------|\n| Auth | Public |\n| Reads | `benchmark_references` |\n| Cache | `Cache-Control: public, max-age=86400` |\n\n**Response 200**:\n```typescript\ntype BenchmarkReferenceResponse = {\n  benchmark_type: BenchmarkType\n  station_name: string\n  unit: string\n  levels: {\n    beginner: { male: number, female: number }\n    intermediate: { male: number, female: number }\n    advanced: { male: number, female: number }\n    elite: { male: number, female: number }\n  }\n}\n\n// Returns: BenchmarkReferenceResponse[]\n```\n\n---\n\n## Rate Limiting Strategy\n\n| Tier | Limit | Applies To |\n|------|-------|-----------|\n| **Chat** | 20 requests/min per user | `POST /api/chat` |\n| **Write** | 30 requests/min per user | All POST/PUT endpoints |\n| **Read** | 60 requests/min per user | All GET endpoints |\n| **Destructive** | 10 requests/min per user | All DELETE endpoints |\n| **Account** | 1 request/hour per user | `DELETE /api/profile` |\n\n**Implementation**: Use Vercel's Edge Config + in-memory rate limiter, or `upstash/ratelimit` with Redis. For v1, a simple in-memory `Map<userId, {count, windowStart}>` in the Route Handler is acceptable given single-user nature.\n\n---\n\n# Deliverable 2: State Management Plan\n\n## 2.1 Library Choices\n\n### Server State: TanStack Query v5\n\n**Why TanStack Query over alternatives**:\n\n| Option | Verdict | Reason |\n|--------|---------|--------|\n| **TanStack Query v5** | \u2705 Chosen | Mature, excellent cache invalidation, optimistic updates, SSR/hydration support, devtools |\n| SWR | \u274c | Simpler but weaker mutation/invalidation story; no built-in optimistic update primitives |\n| Supabase Realtime | \u274c for v1 | Overkill for single-user app; SSE handles chat streaming; adds complexity |\n| React Server Components only | \u274c | Chat UI needs client-side state management; RSCs can't handle streaming chat |\n\n**Configuration**:\n```typescript\n// Shared QueryClient config\n{\n  defaultOptions: {\n    queries: {\n      staleTime: 60_000,              // 1 min default\n      gcTime: 5 * 60_000,             // 5 min garbage collection\n      retry: 1,                        // Retry once on failure\n      refetchOnWindowFocus: false,     // Disable for mobile-first UX\n    },\n    mutations: {\n      retry: 0,                        // Don't retry mutations\n    }\n  }\n}\n```\n\n### Client State: Zustand\n\n**Why Zustand over alternatives**:\n\n| Option | Verdict | Reason |\n|--------|---------|--------|\n| **Zustand** | \u2705 Chosen | Minimal API, no boilerplate, works outside React (timers), tiny bundle (~1KB) |\n| React Context | \u274c | Re-render problems with frequently updating state (chat stream, timers) |\n| Jotai | Considered | Good for atomic state but Zustand is simpler for our slice-based needs |\n| Redux Toolkit | \u274c | Too heavy for this use case |\n\n**Zustand Stores**:\n\n```typescript\n// 1. Chat Store \u2014 manages streaming state\ntype ChatStore = {\n  activeConversationId: string | null\n  streamingMessage: string           // Accumulating streamed tokens\n  isStreaming: boolean\n  error: string | null\n  \n  setActiveConversation: (id: string) => void\n  appendToken: (token: string) => void\n  startStreaming: () => void\n  stopStreaming: () => void\n  setError: (error: string | null) => void\n  reset: () => void\n}\n\n// 2. Onboarding Store \u2014 multi-step form state\ntype OnboardingStore = {\n  currentStep: number                // 0-4\n  formData: Partial<CreateProfileRequest>\n  \n  setStep: (step: number) => void\n  updateFormData: (data: Partial<CreateProfileRequest>) => void\n  reset: () => void\n}\n\n// 3. Workout Timer Store \u2014 for live workout logging\ntype WorkoutTimerStore = {\n  isRunning: boolean\n  startedAt: number | null           // Date.now()\n  elapsed: number                    // Seconds\n  \n  start: () => void\n  pause: () => void\n  resume: () => void\n  stop: () => number                 // Returns final elapsed\n  reset: () => void\n}\n\n// 4. UI Store \u2014 global UI state\ntype UIStore = {\n  sidebarOpen: boolean\n  theme: 'light' | 'dark' | 'system'\n  toasts: Toast[]\n  \n  toggleSidebar: () => void\n  setTheme: (theme: string) => void\n  addToast: (toast: Toast) => void\n  removeToast: (id: string) => void\n}\n```\n\n### Auth State: Supabase Auth + React Context\n\nSupabase Auth manages the session. We wrap it in a thin React Context for consuming in components:\n\n```typescript\ntype AuthContext = {\n  user: User | null\n  session: Session | null\n  isLoading: boolean\n  signIn: (email: string, password: string) => Promise<void>\n  signUp: (email: string, password: string) => Promise<void>\n  signInWithOAuth: (provider: 'google' | 'apple') => Promise<void>\n  signOut: () => Promise<void>\n}\n```\n\n---\n\n## 2.2 Query Key Schema\n\nConsistent, hierarchical query keys for cache management:\n\n```typescript\nconst queryKeys = {\n  // Profile\n  profile: ['profile'] as const,\n  \n  // Conversations\n  conversations: {\n    all: ['conversations'] as const,\n    list: (page: number) => ['conversations', 'list', page] as const,\n    detail: (id: string) => ['conversations', id] as const,\n    messages: (id: string, page: number) => ['conversations', id, 'messages', page] as const,\n  },\n  \n  // Workouts\n  workouts: {\n    all: ['workouts'] as const,\n    list: (filters: WorkoutFilters) => ['workouts', 'list', filters] as const,\n    detail: (id: string) => ['workouts', id] as const,\n  },\n  \n  // Training Plans\n  trainingPlans: {\n    all: ['training-plans'] as const,\n    list: (status?: PlanStatus) => ['training-plans', 'list', status] as const,\n    detail: (id: string) => ['training-plans', id] as const,\n  },\n  \n  // Benchmarks & PRs\n  benchmarks: {\n    all: ['benchmarks'] as const,\n    list: (type?: BenchmarkType) => ['benchmarks', 'list', type] as const,\n    references: ['benchmarks', 'references'] as const,\n  },\n  personalRecords: {\n    all: ['personal-records'] as const,\n    history: (type: BenchmarkType) => ['personal-records', 'history', type] as const,\n  },\n  \n  // Races\n  races: {\n    all: ['races'] as const,\n    detail: (id: string) => ['races', id] as const,\n  },\n  \n  // Goals & Achievements\n  goals: {\n    all: ['goals'] as const,\n    list: (status?: GoalStatus) => ['goals', 'list', status] as const,\n  },\n  achievements: {\n    earned: ['achievements', 'earned'] as const,\n    available: ['achievements', 'available'] as const,\n  },\n  \n  // Dashboard\n  dashboard: ['dashboard'] as const,\n  \n  // Reference (public, long cache)\n  stations: ['stations'] as const,\n  exercises: {\n    all: ['exercises'] as const,\n    list: (category?: string) => ['exercises', 'list', category] as const,\n  },\n}\n```\n\n---\n\n## 2.3 Cache Configuration Per Data Type\n\n```typescript\nconst cacheConfig = {\n  // \u2500\u2500\u2500 Long-lived (rarely changes) \u2500\u2500\u2500\n  profile:            { staleTime: 5 * 60_000 },     // 5 min\n  stations:           { staleTime: Infinity },         // Never stale (static)\n  exercises:          { staleTime: Infinity },         // Never stale (static)\n  benchmarkRefs:      { staleTime: Infinity },         // Never stale (static)\n  achievements:       { staleTime: 5 * 60_000 },      // 5 min\n\n  // \u2500\u2500\u2500 Medium-lived \u2500\u2500\u2500\n  conversationList:   { staleTime: 60_000 },           // 1 min\n  workoutList:        { staleTime: 60_000 },           // 1 min\n  trainingPlanList:   { staleTime: 60_000 },           // 1 min\n  goalList:           { staleTime: 60_000 },           // 1 min\n  raceList:           { staleTime: 2 * 60_000 },       // 2 min\n  personalRecords:    { staleTime: 60_000 },           // 1 min\n\n  // \u2500\u2500\u2500 Short-lived (frequently changes) \u2500\u2500\u2500\n  dashboard:          { staleTime: 30_000 },           // 30s\n  conversationMsgs:   { staleTime: 0 },                // Always refetch (chat is live)\n\n  // \u2500\u2500\u2500 No cache \u2500\u2500\u2500\n  chat:               { staleTime: 0, gcTime: 0 },    // Streaming, no cache\n}\n```\n\n---\n\n## 2.4 Cache Invalidation Map\n\nWhen a mutation succeeds, which queries need to be invalidated?\n\n```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Mutation                         \u2502 Invalidate                               \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Update profile                   \u2502 profile, dashboard                       \u2502\n\u2502                                  \u2502                                          \u2502\n\u2502 Send chat message                \u2502 conversations.messages(id),              \u2502\n\u2502                                  \u2502 conversations.list                       \u2502\n\u2502                                  \u2502                                          \u2502\n\u2502 Create conversation              \u2502 conversations.list                       \u2502\n\u2502                                  \u2502                                          \u2502\n\u2502 Delete conversation              \u2502 conversations.all (full prefix)          \u2502\n\u2502                                  \u2502                                          \u2502\n\u2502 Log workout                      \u2502 workouts.all, dashboard,                 \u2502\n\u2502                                  \u2502 personalRecords.all, trainingPlans.all   \u2502\n\u2502                                  \u2502                                          \u2502\n\u2502 Update/delete workout            \u2502 workouts.all, dashboard,                 \u2502\n\u2502                                  \u2502 personalRecords.all                      \u2502\n\u2502                                  \u2502                                          \u2502\n\u2502 Complete plan day                \u2502 trainingPlans.detail(id), workouts.all,  \u2502\n\u2502                                  \u2502 dashboard, personalRecords.all           \u2502\n\u2502                                  \u2502                                          \u2502\n\u2502 Log benchmark                    \u2502 benchmarks.all, personalRecords.all,     \u2502\n\u2502                                  \u2502 dashboard                                \u2502\n\u2502                                  \u2502                                          \u2502\n\u2502 Log race                         \u2502 races.all, dashboard                     \u2502\n\u2502                                  \u2502                                          \u2502\n\u2502 Update goal                      \u2502 goals.all, achievements.all, dashboard   \u2502\n\u2502                                  \u2502                                          \u2502\n\u2502 Create/update/archive plan       \u2502 trainingPlans.all, dashboard             \u2502\n\u2502                                  \u2502                                          \u2502\n\u2502 Submit message feedback          \u2502 conversations.messages(convId)           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n---\n\n## 2.5 Optimistic Updates\n\nOnly apply optimistic updates where the UI feels laggy without them and the success probability is very high:\n\n| Mutation | Optimistic? | Strategy |\n|----------|-------------|----------|\n| Send chat message | \u2705 Yes | Append user message to message list immediately, show streaming placeholder |\n| Toggle message feedback | \u2705 Yes | Toggle icon immediately, rollback on error |\n| Mark plan day complete | \u2705 Yes | Check the checkbox immediately, rollback on error |\n| Update goal progress | \u2705 Yes | Update progress bar immediately |\n| Log workout | \u274c No | Form submission \u2014 show loading spinner, redirect on success |\n| Delete conversation | \u274c No | Show confirmation dialog, then loading state |\n| Create training plan | \u274c No | Complex multi-write \u2014 show loading overlay |\n\n---\n\n## 2.6 Data Flow Diagrams\n\n### Chat Message Flow\n\n```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 User types   \u2502\n\u2502 message      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502\n       \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 ChatInput component                  \u2502\n\u2502 1. Zustand: chatStore.startStreaming \u2502\n\u2502 2. Optimistic: append user msg      \u2502\n\u2502 3. POST /api/chat (SSE fetch)       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n               \u2502\n               \u25bc (SSE stream)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Stream handler (client)              \u2502\n\u2502 1. For each token:                   \u2502\n\u2502    chatStore.appendToken(token)      \u2502\n\u2502 2. On [DONE]:                        \u2502\n\u2502    chatStore.stopStreaming()          \u2502\n\u2502    queryClient.invalidateQueries(    \u2502\n\u2502      conversations.messages(id))     \u2502\n\u2502    queryClient.invalidateQueries(    \u2502\n\u2502      conversations.list)             \u2502\n\u2502 3. On error:                         \u2502\n\u2502    chatStore.setError(msg)           \u2502\n\u2502    Show retry button                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n               \u2502\n               \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 ChatMessages component               \u2502\n\u2502 - Renders from TanStack Query cache  \u2502\n\u2502   (messages from DB) +               \u2502\n\u2502   Zustand streaming buffer           \u2502\n\u2502 - After invalidation: DB messages    \u2502\n\u2502   include the new pair               \u2502\n\u2502 - Streaming buffer clears            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n### Log Workout Flow\n\n```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 WorkoutForm      \u2502\n\u2502 (client comp)    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502 Submit\n       \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 useMutation('logWorkout')            \u2502\n\u2502 1. Show loading state on button      \u2502\n\u2502 2. POST /api/workouts                \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n               \u2502\n               \u25bc (server)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Route Handler                        \u2502\n\u2502 1. Zod validate                      \u2502\n\u2502 2. Insert workout                    \u2502\n\u2502 3. Check PRs                         \u2502\n\u2502 4. If PR: insert personal_records    \u2502\n\u2502 5. Return { workout, new_prs }       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n               \u2502\n               \u25bc (client onSuccess)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 onSuccess handler                    \u2502\n\u2502 1. invalidateQueries([              \u2502\n\u2502      'workouts',                     \u2502\n\u2502      'dashboard',                    \u2502\n\u2502      'personal-records',             \u2502\n\u2502      'training-plans'                \u2502\n\u2502    ])                                \u2502",
          "type": "output_text"
        }
      ],
      "id": "msg_0dbb265c-6003-41ed-a801-6823220a3d16",
      "role": "assistant",
      "status": "completed",
      "type": "message"
    }
  ],
  "status": "completed",
  "usage": {
    "cost": {
      "currency": "USD",
      "input_cost": 0.5505,
      "output_cost": 0.42418,
      "tool_calls_cost": 0.0115,
      "total_cost": 0.98618
    },
    "input_tokens": 110100,
    "output_tokens": 16967,
    "tool_calls_details": {
      "fetch_url": {
        "invocation": 3
      },
      "search_web": {
        "invocation": 2
      }
    },
    "total_tokens": 127067
  }
}